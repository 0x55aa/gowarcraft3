package w3gs

import (
	"hash/crc32"
	"net"

	"github.com/nielsAD/noot/pkg/util"
)

// AF_INET
const connAddressFamily uint16 = 2

// ConnAddr stores a single socket connection tuple (port+ip).
type ConnAddr struct {
	Port uint16
	IP   net.IP
}

func (ca *ConnAddr) write(buf *util.PacketBuffer) error {
	buf.WriteUInt16(connAddressFamily)
	buf.WritePort(ca.Port)
	if err := buf.WriteIP(ca.IP); err != nil && ca.IP != nil {
		return err
	}

	buf.WriteUInt32(0)
	buf.WriteUInt32(0)
	return nil
}

func (ca *ConnAddr) read(buf *util.PacketBuffer) {
	buf.Skip(2)
	ca.Port = buf.ReadPort()
	ca.IP = buf.ReadIP()
	buf.Skip(8)
}

// UnknownPacket is used to store unknown packets.
type UnknownPacket struct {
	Blob []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *UnknownPacket) MarshalBinary() ([]byte, error) {
	return pkt.Blob, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *UnknownPacket) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return ErrWrongSize
	}
	pkt.Blob = append([]byte(nil), data...)
	return nil
}

// Ping implements the [0x01] W3GS_PING_FROM_HOST packet (S -> C).
//
// This is sent every 30 seconds to make sure that the client is still responsive.
//
// Format:
//
//    (UINT32) Ping
//
type Ping struct {
	Payload uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *Ping) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: []byte{ProtocolSig, PidPingFromHost, 8, 0, 0, 0, 0, 0}}
	buf.WriteUInt32At(4, pkt.Payload)
	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *Ping) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.Payload = buf.ReadUInt32()
	return nil
}

// Pong implements the [0x46] W3GS_PONG_TO_HOST packet (C -> S).
//
// This is sent in response to 0x01 W3GS_PING_FROM_HOST.
//
// The pong value is just a copy of whatever was sent in SEND_W3GS_PING_FROM_HOST which was GetTicks( ) at the time of sending
// so as long as we trust that the client isn't trying to fake us out and mess with the pong value we can find the round trip time by simple subtraction
// (the subtraction is done elsewhere because the very first pong value seems to be 1 and we want to discard that one)
//
// Format:
//
//    (UINT32) Pong
//
type Pong struct {
	Ping
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *Pong) MarshalBinary() ([]byte, error) {
	var data, err = pkt.Ping.MarshalBinary()
	data[1] = PidPongToHost
	return data, err
}

// PeerPing implements the [0x35] W3GS_PING_FROM_OTHERS packet (C -> C).
//
// Client requests an echo from another client (occurs every 10 seconds).
//
// Format:
//
//    (UINT32) Ping
//    (UINT32) Peer key ?
//    (UINT32) Unknown (0)
//
type PeerPing struct {
	Payload uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PeerPing) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 16)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPingFromOthers)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(pkt.Payload)
	buf.WriteUInt32(0)
	buf.WriteUInt32(0)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PeerPing) UnmarshalBinary(data []byte) error {
	if len(data) != 16 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.Payload = buf.ReadUInt32()
	return nil
}

// PeerPong implements the [0x36] W3GS_PONG_TO_OTHERS packet (C -> C).
//
// This is sent in response to an echo from another client.
//
// Format:
//
//    (UINT32) Pong
//
type PeerPong struct {
	Ping
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PeerPong) MarshalBinary() ([]byte, error) {
	var data, err = pkt.Ping.MarshalBinary()
	data[1] = PidPongToOthers
	return data, err
}

// Join implements the [0x1E] W3GS_ReqJoin packet (C -> S).
//
// A client sends this to the host to enter the game lobby.
//
// The internal IP uses the Windows in_addr structure which is thus used by the sockaddr_in structure.
//
// Format:
//
//    (UINT32) Host Counter (Game ID)
//    (UINT32) Entry Key (used in LAN)
//    (UINT8) Unknown (0x00)
//    (UINT16) Listen Port
//    (UINT32) Join counter
//    (STRING) Player name
//    (UINT8) Number of bytes that follow (0x01 < 1.29; 0x02 >= 1.29)
//    (UINT8)[] Unknown (0x00)
//    (UINT16) AF_INET (0x02)
//    (UINT16) Internal Port
//    (UINT32) Internal IP
//    (UINT32) Unknown (0x00)
//    (UINT32) Unknown (0x00)
//
type Join struct {
	HostCounter  uint32
	EntryKey     uint32
	ListenPort   uint16
	JoinCounter  uint32
	PlayerName   string
	InternalAddr ConnAddr
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *Join) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 38+len(pkt.PlayerName))}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidReqJoin)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.EntryKey)

	buf.WriteUInt8(0)

	buf.WriteUInt16(pkt.ListenPort)
	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteString(pkt.PlayerName)

	buf.WriteUInt8(1)
	buf.WriteUInt8(0)

	if err := pkt.InternalAddr.write(&buf); err != nil {
		return nil, err
	}

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *Join) UnmarshalBinary(data []byte) error {
	if len(data) < 38 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.HostCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()

	buf.Skip(1)

	pkt.ListenPort = buf.ReadUInt16()
	pkt.JoinCounter = buf.ReadUInt32()

	var err error
	if pkt.PlayerName, err = buf.ReadString(); err != nil {
		return err
	}

	if buf.Size() < 17 {
		return ErrWrongSize
	}

	buf.Skip(int(buf.ReadUInt8()))

	if buf.Size() != 16 {
		return ErrWrongSize
	}

	pkt.InternalAddr.read(&buf)

	return nil
}

// RejectJoin implements the [0x05] W3GS_RejectJoin packet (S -> C).
//
// This is sent in a response to a request to join the game lobby and indicates that the request was denied.
//
// Reason:
//
//    0x09 RejectJoin_FULL      The game lobby is full
//    0x07 RejectJoin_INVALID   There was an error in your request
//    0x10 RejectJoin_STARTED   The game has already been started
//    0x27 RejectJoin_WRONGPASS The password you sent was incorrect
//
// Format:
//
//    (UINT32) Reason
//
type RejectJoin struct {
	Reason uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *RejectJoin) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: []byte{ProtocolSig, PidRejectJoin, 8, 0, 0, 0, 0, 0}}
	buf.WriteUInt32At(4, pkt.Reason)
	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *RejectJoin) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.Reason = buf.ReadUInt32()
	return nil
}

// SlotInfoJoin implements the [0x04] W3GS_SlotInfoJoin packet (S -> C).
//
// This is sent to tell the client about the game slots, upon entry of the lobby.
//
// Format:
//
//    Embedded [0x09] W3GS_SlotInfo:
//	     (UINT16)   Length of Slot data
//	     (UINT8)    Number of slots
//	     (UINT8)[]  Slot data
//	    (UINT32)    Random seed
//	     (UINT8)    Slots layout
//	     (UINT8)    Number of player slots without observers
//
//     (UINT8)    Player number
//    (UINT16)    AF_INET (0x02)
//    (UINT16)    Port
//    (UINT32)    External IP
//    (UINT32)    Unknown (0x00)
//    (UINT32)    Unknown (0x00)
//
type SlotInfoJoin struct {
	SlotInfo
	PlayerID     uint8
	ExternalAddr ConnAddr
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *SlotInfoJoin) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 30+len(pkt.Slots)*9)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSlotInfoJoin)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	pkt.SlotInfo.write(&buf)
	buf.WriteUInt8(pkt.PlayerID)

	if err := pkt.ExternalAddr.write(&buf); err != nil {
		return nil, err
	}

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *SlotInfoJoin) UnmarshalBinary(data []byte) error {
	if len(data) < 30 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}

	if err := pkt.SlotInfo.read(&buf); err != nil {
		return err
	}

	if buf.Size() != 17 {
		return ErrWrongSize
	}

	pkt.PlayerID = buf.ReadUInt8()
	pkt.ExternalAddr.read(&buf)

	return nil
}

// SlotInfo implements the [0x09] W3GS_SlotInfo packet (S -> C).
//
// This is sent for slot updates.
//
// The length of slot info should always be `0x0B`.
//
// Format:
//
//     (UINT16)   Length of Slot data
//     (UINT8)    Number of slots
//     (UINT8) [] Slot data
//    (UINT32)    Random seed
//     (UINT8)    Slots layout
//     (UINT8)    Number of player slots without observers
//
//    For each slot:
//       (UINT8) Player number
//       (UINT8) Download status
//       (UINT8) Slot status
//       (UINT8) Computer status
//       (UINT8) Team
//       (UINT8) Color
//       (UINT8) Race
//       (UINT8) Computer type
//       (UINT8) Handicap
//
type SlotInfo struct {
	Slots      []SlotData
	RandomSeed uint32
	SlotLayout uint8
	NumPlayers uint8
}

// SlotData stores the info for a single game slot.
//
// **Download status:**
//
// - This is a percentage of their download progress. As such, this value can only be between 0 and 100.
//
// Slot status:
//
//    0x00 Open
//    0x01 Closed
//    0x02 Occupied
//
// Computer status:
//
//    0x00 Human
//    0x01 Computer
//
// Race:
//
//    0x01 Human
//    0x02 Orc
//    0x04 Night Elf
//    0x08 Undead
//    0x20 Random
//    0x40 Selectable
//
// Computer type:
//
//    0x00 Easy
//    0x01 Normal / Human
//    0x02 Hard
//
//    (UINT8) Player number
//    (UINT8) Download status
//    (UINT8) Slot status
//    (UINT8) Computer status
//    (UINT8) Team
//    (UINT8) Color
//    (UINT8) Race
//    (UINT8) Computer type
//    (UINT8) Handicap
//
type SlotData struct {
	PlayerID       uint8
	DownloadStatus uint8
	SlotStatus     uint8
	Computer       bool
	Team           uint8
	Color          uint8
	Race           uint8
	ComputerType   uint8
	Handicap       uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *SlotInfo) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 13+len(pkt.Slots)*9)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSlotInfo)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	pkt.write(&buf)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *SlotInfo) UnmarshalBinary(data []byte) error {
	if len(data) < 13 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}

	if err := pkt.read(&buf); err != nil {
		return err
	}

	if buf.Size() != 0 {
		return ErrWrongSize
	}

	return nil
}

func (pkt *SlotInfo) write(buf *util.PacketBuffer) {
	buf.WriteUInt16(uint16(7 + len(pkt.Slots)*9))
	buf.WriteUInt8(uint8(len(pkt.Slots)))

	for i := 0; i < len(pkt.Slots); i++ {
		buf.WriteUInt8(pkt.Slots[i].PlayerID)
		buf.WriteUInt8(pkt.Slots[i].DownloadStatus)
		buf.WriteUInt8(pkt.Slots[i].SlotStatus)
		buf.WriteBool(pkt.Slots[i].Computer)
		buf.WriteUInt8(pkt.Slots[i].Team)
		buf.WriteUInt8(pkt.Slots[i].Color)
		buf.WriteUInt8(pkt.Slots[i].Race)
		buf.WriteUInt8(pkt.Slots[i].ComputerType)
		buf.WriteUInt8(pkt.Slots[i].Handicap)
	}

	buf.WriteUInt32(pkt.RandomSeed)
	buf.WriteUInt8(pkt.SlotLayout)
	buf.WriteUInt8(pkt.NumPlayers)
}

func (pkt *SlotInfo) read(buf *util.PacketBuffer) error {
	var slotSize = int(buf.ReadUInt16())
	var numSlots = int(buf.ReadUInt8())

	if buf.Size()+1 < slotSize || slotSize != 7+numSlots*9 {
		return ErrWrongSize
	}

	if numSlots > 0 {
		pkt.Slots = make([]SlotData, numSlots)
		for i := 0; i < len(pkt.Slots); i++ {
			pkt.Slots[i].PlayerID = buf.ReadUInt8()
			pkt.Slots[i].DownloadStatus = buf.ReadUInt8()
			pkt.Slots[i].SlotStatus = buf.ReadUInt8()
			pkt.Slots[i].Computer = buf.ReadBool()
			pkt.Slots[i].Team = buf.ReadUInt8()
			pkt.Slots[i].Color = buf.ReadUInt8()
			pkt.Slots[i].Race = buf.ReadUInt8()
			pkt.Slots[i].ComputerType = buf.ReadUInt8()
			pkt.Slots[i].Handicap = buf.ReadUInt8()
		}
	} else {
		pkt.Slots = nil
	}

	pkt.RandomSeed = buf.ReadUInt32()
	pkt.SlotLayout = buf.ReadUInt8()
	pkt.NumPlayers = buf.ReadUInt8()

	return nil
}

// PlayerInfo implements the [0x06] W3GS_PlayerInfo packet (S -> C).
//
// Tells a client about a player's information.
//
// The external and internal IP are always zero for the host.
//
// NOTE: This packet needs a better structure in the Format. Until then, you will have to deal with the unorganized fields.
//
// Format:
//
//     (UINT32) Player Counter
//      (UINT8) Player number
//    (STRING) Player name
//      (UINT16) Unknown (0x01)
//      (UINT16) AF_INET (0x02)
//      (UINT16) Port
//     (UINT32) External IP
//     (UINT32) Unknown (0x00)
//     (UINT32) Unknown (0x00)
//      (UINT16) AF_INET (0x02)
//      (UINT16) Port
//     (UINT32) Internal IP
//     (UINT32) Unknown (0x00)
//     (UINT32) Unknown (0x00)
//
type PlayerInfo struct {
	JoinCounter  uint32
	PlayerID     uint8
	PlayerName   string
	ExternalAddr ConnAddr
	InternalAddr ConnAddr
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PlayerInfo) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 44+len(pkt.PlayerName))}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerInfo)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteUInt8(pkt.PlayerID)
	buf.WriteString(pkt.PlayerName)

	buf.WriteUInt16(1)

	if err := pkt.ExternalAddr.write(&buf); err != nil {
		return nil, err
	}

	if err := pkt.InternalAddr.write(&buf); err != nil {
		return nil, err
	}

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PlayerInfo) UnmarshalBinary(data []byte) error {
	if len(data) < 44 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.JoinCounter = buf.ReadUInt32()
	pkt.PlayerID = buf.ReadUInt8()

	var err error
	if pkt.PlayerName, err = buf.ReadString(); err != nil {
		return err
	}
	if len(data) != 44+len(pkt.PlayerName) {
		return ErrWrongSize
	}

	buf.Skip(2)
	pkt.ExternalAddr.read(&buf)
	pkt.InternalAddr.read(&buf)

	return nil
}

// Leave implements the [0x21] W3GS_LeaveReq packet (C -> S).
//
// A client requests to leave.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT32) Reason
//
type Leave struct {
	Reason uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *Leave) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: []byte{ProtocolSig, PidLeaveReq, 8, 0, 0, 0, 0, 0}}
	buf.WriteUInt32At(4, pkt.Reason)
	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *Leave) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.Reason = buf.ReadUInt32()
	return nil
}

// PlayerKicked implements the [0x1C] W3GS_PlayerKicked packet (S -> C).
//
// The host has kicked the client from the lobby.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT32) Reason
//
type PlayerKicked struct {
	Leave
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PlayerKicked) MarshalBinary() ([]byte, error) {
	var data, err = pkt.Leave.MarshalBinary()
	data[1] = PidPlayerKicked
	return data, err
}

// LeaveAck implements the [0x1B] W3GS_LeaveAck packet (S -> C).
//
// This is the response to 0x21 W3GS_LeaveReq.
//
// You will leave the game once the connection is terminated.
//
// Format:
//
//    [blank]
//
type LeaveAck struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *LeaveAck) MarshalBinary() ([]byte, error) {
	return []byte{ProtocolSig, PidLeaveAck, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *LeaveAck) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return ErrWrongSize
	}
	return nil
}

// PlayerLeft implements the [0x07] W3GS_PlayerLeft packet (S -> C).
//
// This is received from the game host when a player leaves.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT8) Player number
//    (UINT32) Reason
//
type PlayerLeft struct {
	PlayerID uint8
	Reason   uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PlayerLeft) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: []byte{ProtocolSig, PidPlayerLeft, 9, 0, pkt.PlayerID, 0, 0, 0, 0}}
	buf.WriteUInt32At(5, pkt.Reason)
	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PlayerLeft) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.PlayerID = buf.ReadUInt8()
	pkt.Reason = buf.ReadUInt32()
	return nil
}

// CountDownStart implements the [0x0A] W3GS_COUNTDOWN_START packet (S -> C).
//
// The game has begun the countdown to start.
//
// The official clients countdown from 5 seconds, however it is possible to use any time you wish. For example, the GHost++ bot uses 10 seconds when auto-hosted, but 5 seconds when started using an administrative command.
//
// Format:
//
//    [blank]
//
type CountDownStart struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *CountDownStart) MarshalBinary() ([]byte, error) {
	return []byte{ProtocolSig, PidCountDownStart, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *CountDownStart) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return ErrWrongSize
	}
	return nil
}

// CountDownEnd implements the [0x0B] W3GS_COUNTDOWN_END packet (S -> C).
//
// The game has finished the countdown and has now started. Players should see a loading screen for the map once this is received.
//
// W3GS_COUNTDOWN_START should be received before this packet, even if there is no countdown or if the countdown was 0 seconds.
//
// Format:
//
//    [blank]
//
type CountDownEnd struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *CountDownEnd) MarshalBinary() ([]byte, error) {
	return []byte{ProtocolSig, PidCountDownEnd, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *CountDownEnd) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return ErrWrongSize
	}
	return nil
}

// GameLoaded implements the [0x23] W3GS_GAMELOADED_SELF packet (C -> S).
//
// The client sends this to the host when they have finished loading the map.
//
// Format:
//
//    [blank]
//
type GameLoaded struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *GameLoaded) MarshalBinary() ([]byte, error) {
	return []byte{ProtocolSig, PidGameLoadedSelf, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *GameLoaded) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return ErrWrongSize
	}
	return nil
}

// PlayerLoaded implements the [0x08] W3GS_PlayerLoaded packet (S -> C).
//
// Sent to all other clients in-game to notify that a player has finished loading.
//
// Format:
//
//    (UINT8) Player number
//
type PlayerLoaded struct {
	PlayerID uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PlayerLoaded) MarshalBinary() ([]byte, error) {
	return []byte{ProtocolSig, PidPlayerLoaded, 5, 0, pkt.PlayerID}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PlayerLoaded) UnmarshalBinary(data []byte) error {
	if len(data) != 5 {
		return ErrWrongSize
	}
	pkt.PlayerID = data[4]
	return nil
}

// StartLag implements the [0x10] W3GS_START_LAG packet (S -> C).
//
// This is sent to the clients to initiate the lag screen.
//
// Format:
//
//    (UINT8) Number of lagging players
//
//    For every lagging player:
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type StartLag struct {
	Players []LagPlayer
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *StartLag) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 5+len(pkt.Players)*5)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStartLag)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt8(uint8(len(pkt.Players)))
	for i := 0; i < len(pkt.Players); i++ {
		pkt.Players[i].write(&buf)
	}

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *StartLag) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	var numPlayers = int(buf.ReadUInt8())

	if len(data) != 5+numPlayers*5 {
		return ErrWrongSize
	}

	if numPlayers > 0 {
		pkt.Players = make([]LagPlayer, numPlayers)
		for i := 0; i < len(pkt.Players); i++ {
			pkt.Players[i].read(&buf)
		}
	} else {
		pkt.Players = nil
	}

	return nil
}

// LagPlayer stores the data for a single lagging player.
//
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type LagPlayer struct {
	PlayerID      uint8
	LagDurationMS uint32
}

func (lp *LagPlayer) write(buf *util.PacketBuffer) {
	buf.WriteUInt8(lp.PlayerID)
	buf.WriteUInt32(lp.LagDurationMS)
}

func (lp *LagPlayer) read(buf *util.PacketBuffer) {
	lp.PlayerID = buf.ReadUInt8()
	lp.LagDurationMS = buf.ReadUInt32()
}

// StopLag implements the [0x11] W3GS_STOP_LAG packet (S -> C).
//
// This is sent to the clients to indicate that a player stopped lagging.
//
// Format:
//
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type StopLag struct {
	LagPlayer
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *StopLag) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 9)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStopLag)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	pkt.LagPlayer.write(&buf)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *StopLag) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.LagPlayer.read(&buf)
	return nil
}

// DropLaggers implements the [0x2F] W3GS_STOP_DROPREQ packet (C -> S).
//
// This is sent when a player votes to drop lagging players.
//
// Format:
//
//    Unknown
//
type DropLaggers struct {
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *DropLaggers) MarshalBinary() ([]byte, error) {
	return []byte{ProtocolSig, PidDropReq, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *DropLaggers) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return ErrWrongSize
	}
	return nil
}

// GameAction implements the [0x26] W3GS_OUTGOING_ACTION packet (C -> S).
//
// A client sends this to the game host to execute an action in-game.
//
// Format:
//
//    (UINT32) CRC-32 encryption
//    (VOID) Action data
//
type GameAction struct {
	Data []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *GameAction) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 8+len(pkt.Data))}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidOutgoingAction)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.WriteBlob(pkt.Data)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *GameAction) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	var crc = buf.ReadUInt32()

	pkt.Data = append([]byte(nil), data[8:]...)
	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return ErrInvalidChecksum
	}

	return nil
}

// TimeSlot implements the [0x0C] W3GS_INCOMING_ACTION packet (S -> C).
//
// Informs the client about an action in-game.
//
// Format:
//
//    (UINT16) Send interval
//    (UINT16) CRC-16 encryption
//
//    For each action:
//    (UINT8) Player number
//    (UINT16) Length of action data
//    (VOID) Action data
//
type TimeSlot struct {
	Fragment        bool
	TimeIncrementMS uint16
	Actions         []PlayerAction
}

// PlayerAction stores the data for a single game action.
//
//    (UINT8) Player number
//    (UINT16) Length of action data
//    (VOID) Action data
//
type PlayerAction struct {
	PlayerID uint8
	Data     []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *TimeSlot) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 8+len(pkt.Actions)*16)}
	buf.WriteUInt8(ProtocolSig)

	if pkt.Fragment {
		buf.WriteUInt8(PidIncomingAction2)
	} else {
		buf.WriteUInt8(PidIncomingAction)
	}

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt16(pkt.TimeIncrementMS)

	// Placeholder for CRC
	buf.WriteUInt16(0)

	for i := 0; i < len(pkt.Actions); i++ {
		buf.WriteUInt8(pkt.Actions[i].PlayerID)
		buf.WriteUInt16(uint16(len(pkt.Actions[i].Data)))
		buf.WriteBlob(pkt.Actions[i].Data)
	}

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	// Set CRC
	buf.WriteUInt16At(6, uint16(crc32.ChecksumIEEE(buf.Bytes[8:])))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *TimeSlot) UnmarshalBinary(data []byte) error {
	if len(data) < 6 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[1:]}
	pkt.Fragment = buf.ReadUInt8() == PidIncomingAction2

	buf.Skip(2)
	pkt.TimeIncrementMS = buf.ReadUInt16()

	if len(data) == 6 {
		pkt.Actions = nil
		return nil
	}

	var crc = buf.ReadUInt16()
	if crc != uint16(crc32.ChecksumIEEE(data[8:])) {
		return ErrInvalidChecksum
	}

	for buf.Size() > 3 {
		var action = PlayerAction{
			PlayerID: buf.ReadUInt8(),
		}

		var size = int(buf.ReadUInt16())
		if buf.Size() < size {
			return ErrMalformedData
		}

		action.Data = buf.ReadBlob(int(size))
		pkt.Actions = append(pkt.Actions, action)
	}

	if buf.Size() != 0 {
		return ErrWrongSize
	}

	return nil
}

// TimeSlotAck implements the [0x27] W3GS_OUTGOING_KEEPALIVE packet (C -> S).
//
// This is sent to the host from each client.
//
// The unknown value may be a checksum and is also used in replays.
//
// Format:
//
//    (UINT8)  Unknown
//    (UINT32) Checksum
//
type TimeSlotAck struct {
	Checksum uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *TimeSlotAck) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: []byte{ProtocolSig, PidOutgoingKeepAlive, 9, 0, 0, 0, 0, 0, 0}}
	buf.WriteUInt32At(5, pkt.Checksum)
	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *TimeSlotAck) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[5:]}
	pkt.Checksum = buf.ReadUInt32()
	return nil
}

// Message implements the [0x28] W3GS_CHAT_TO_HOST packet (C -> S).
//
// This is sent from the client to the host to send a message to the other clients.
//
// Format:
//
//    (UINT8) Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8) From player number
//    (UINT8) Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type Message struct {
	RecipientIDs []uint8
	SenderID     uint8
	Flags        uint8
	NewVal       uint8
	ExtraFlags   uint32
	Content      string
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *Message) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 12+len(pkt.RecipientIDs)+len(pkt.Content))}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidChatToHost)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt8(uint8(len(pkt.RecipientIDs)))
	buf.WriteBlob(pkt.RecipientIDs)
	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt8(pkt.Flags)

	switch pkt.Flags {
	case ChatMessageExtra:
		buf.WriteUInt32(pkt.ExtraFlags)
		fallthrough
	case ChatMessage:
		buf.WriteString(pkt.Content)
	default:
		buf.WriteUInt8(pkt.NewVal)
	}

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *Message) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	var numRecipients = int(buf.ReadUInt8())

	if len(data) < 8+numRecipients {
		return ErrWrongSize
	}

	pkt.RecipientIDs = buf.ReadBlob(numRecipients)
	pkt.SenderID = buf.ReadUInt8()
	pkt.Flags = buf.ReadUInt8()

	switch pkt.Flags {
	case ChatMessageExtra:
		pkt.ExtraFlags = buf.ReadUInt32()
		if buf.Size() < 1 {
			return ErrWrongSize
		}
		fallthrough
	case ChatMessage:
		var err error
		if pkt.Content, err = buf.ReadString(); err != nil {
			return err
		}
	default:
		pkt.NewVal = buf.ReadUInt8()
	}

	if buf.Size() != 0 {
		return ErrWrongSize
	}

	return nil
}

// MessageRelay implements the [0x0F] W3GS_CHAT_FROM_HOST packet (S -> C).
//
// This is sent to the clients to print a message on the screen from another player.
//
// Format:
//
//    (UINT8) Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8) From player number
//    (UINT8) Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type MessageRelay struct {
	Message
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MessageRelay) MarshalBinary() ([]byte, error) {
	var data, err = pkt.Message.MarshalBinary()
	if data != nil {
		data[1] = PidChatFromHost
	}
	return data, err
}

// SearchGame implements the [0x2F] W3GS_SearchGame packet (C -> S).
//
// This is sent to the entire local area network to detect games.
//
// Product is either WAR3 or W3XP.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Unknown (0x00)
//
type SearchGame struct {
	GameVersion
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *SearchGame) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 16)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSearchGame)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	pkt.GameVersion.write(&buf)
	buf.WriteUInt32(0)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *SearchGame) UnmarshalBinary(data []byte) error {
	if len(data) != 16 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}

	pkt.GameVersion.read(&buf)

	return nil
}

// GameVersion stores the game version tuple.
//
//    (UINT32) Product
//    (UINT32) Version
//
type GameVersion struct {
	TFT     bool
	Version uint32
}

// Game versions
var (
	gameWAR3 = "3RAW"
	gameW3XP = "PX3W"
)

func (gv *GameVersion) write(buf *util.PacketBuffer) {
	if gv.TFT {
		buf.WriteBlob([]byte(gameW3XP))
	} else {
		buf.WriteBlob([]byte(gameWAR3))
	}
	buf.WriteUInt32(gv.Version)
}

func (gv *GameVersion) read(buf *util.PacketBuffer) {
	gv.TFT = string(buf.ReadBlob(4)) == gameW3XP
	gv.Version = buf.ReadUInt32()
}

// GameInfo implements the [0x30] W3GS_GameInfo packet (S -> C).
//
// This is sent every 5 seconds over a UDP broadcast to update the local area network about the game.
//
// This is also sent when a client clicks on the game in a list.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Host Counter
//    (UINT32) Entry key
//    (STRING) Game name
//    (UINT8) Unknown (0x00)
//    (STRING) Statstring
//    (UINT32) Slots total
//    (UINT32) Game Type Info
//    (UINT32) Unknown (0x01)
//    (UINT32) Slots available
//    (UINT32) Time since creation
//    (UINT16) Game Port
//
type GameInfo struct {
	GameVersion
	HostCounter    uint32
	EntryKey       uint32
	GameName       string
	StatString     string
	SlotsTotal     uint32
	GameTypeFlags  uint32
	SlotsAvailable uint32
	UptimeSec      uint32
	GamePort       uint16
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *GameInfo) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 45+len(pkt.GameName)+len(pkt.StatString))}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGameInfo)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	pkt.GameVersion.write(&buf)
	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.EntryKey)
	buf.WriteString(pkt.GameName)
	buf.WriteUInt8(0)
	buf.WriteString(pkt.StatString)
	buf.WriteUInt32(pkt.SlotsTotal)
	buf.WriteUInt32(pkt.GameTypeFlags)
	buf.WriteUInt32(1)
	buf.WriteUInt32(pkt.SlotsAvailable)
	buf.WriteUInt32(pkt.UptimeSec)
	buf.WriteUInt16(pkt.GamePort)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *GameInfo) UnmarshalBinary(data []byte) error {
	if len(data) < 45 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.GameVersion.read(&buf)
	pkt.HostCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()

	var err error
	if pkt.GameName, err = buf.ReadString(); err != nil {
		return err
	}
	if len(data) < 45+len(pkt.GameName) {
		return ErrWrongSize
	}

	buf.Skip(1)
	if pkt.StatString, err = buf.ReadString(); err != nil {
		return err
	}
	if len(data) != 45+len(pkt.GameName)+len(pkt.StatString) {
		return ErrWrongSize
	}

	pkt.SlotsTotal = buf.ReadUInt32()
	pkt.GameTypeFlags = buf.ReadUInt32()

	buf.Skip(4)
	pkt.SlotsAvailable = buf.ReadUInt32()
	pkt.UptimeSec = buf.ReadUInt32()
	pkt.GamePort = buf.ReadUInt16()

	return nil
}

// CreateGame implements the [0x31] W3GS_CreateGame packet (S -> C).
//
// Notifies the local area network that a game was created.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) HostCounter
//
type CreateGame struct {
	GameVersion
	HostCounter uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *CreateGame) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 16)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidCreateGame)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	pkt.GameVersion.write(&buf)
	buf.WriteUInt32(pkt.HostCounter)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *CreateGame) UnmarshalBinary(data []byte) error {
	if len(data) != 16 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.GameVersion.read(&buf)
	pkt.HostCounter = buf.ReadUInt32()

	return nil
}

// RefreshGame implements the [0x32] W3GS_RefreshGame packet (S -> C).
//
// Notifies the local area network about a game (occurs every 5 seconds or refresh slots).
//
// Format:
//
//    (UINT32) Host Counter
//    (UINT32) Players In Game
//    (UINT32) Slots available
//
type RefreshGame struct {
	HostCounter    uint32
	PlayersInGame  uint32
	SlotsAvailable uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *RefreshGame) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 16)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidRefreshGame)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.PlayersInGame)
	buf.WriteUInt32(pkt.SlotsAvailable)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *RefreshGame) UnmarshalBinary(data []byte) error {
	if len(data) != 16 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.HostCounter = buf.ReadUInt32()
	pkt.PlayersInGame = buf.ReadUInt32()
	pkt.SlotsAvailable = buf.ReadUInt32()

	return nil
}

// DecreateGame implements the [0x33] W3GS_DecreateGame packet (S -> C).
//
// Notifies the local area network that a game is no longer being hosted.
//
// Format:
//
//    (UINT32) Host Counter
//
type DecreateGame struct {
	HostCounter uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *DecreateGame) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: []byte{ProtocolSig, PidDecreateGame, 8, 0, 0, 0, 0, 0}}
	buf.WriteUInt32At(4, pkt.HostCounter)
	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *DecreateGame) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.HostCounter = buf.ReadUInt32()
	return nil
}

// ClientInfo implements the [0x37] W3GS_ClientInfo packet (C -> S).
//
// A client sends this to another client to gain information about self when connected.
//
// Format:
//
//    (UINT32) Player Counter
//    (UINT32) Entry key
//    (UINT8) Player number
//    (UINT8) Unknown (0xFF, status?)
//    (UINT32) Unknown (peer key?)
//
type ClientInfo struct {
	JoinCounter uint32
	EntryKey    uint32
	PlayerID    uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *ClientInfo) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 18)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidClientInfo)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteUInt32(pkt.EntryKey)
	buf.WriteUInt8(pkt.PlayerID)

	buf.WriteUInt8(0xFF)

	buf.WriteUInt32(0)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *ClientInfo) UnmarshalBinary(data []byte) error {
	if len(data) != 18 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.JoinCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()
	pkt.PlayerID = buf.ReadUInt8()

	return nil
}

// MapCheck implements the [0x3D] W3GS_MapCheck packet (S -> C).
//
// This is sent from the game host to a client that just joined to check if the client has the map.
//
// The map info is the actual CRC and the other CRC is actually an "xoro" value.
//
// Format:
//
//    (UINT32) Unknown (0x01)
//    (STRING) File Path
//    (UINT32) File size
//    (UINT32) Map info
//    (UINT32) File CRC encryption
//    (UINT8)[20] File SHA-1 hash
//
type MapCheck struct {
	FilePath          string
	FileSize          uint32
	MapInfo           uint32
	FileCrcEncryption uint32
	FileSha1Hash      [20]byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapCheck) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 41+len(pkt.FilePath))}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapCheck)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(1)
	buf.WriteString(pkt.FilePath)
	buf.WriteUInt32(pkt.FileSize)
	buf.WriteUInt32(pkt.MapInfo)
	buf.WriteUInt32(pkt.FileCrcEncryption)
	buf.WriteBlob(pkt.FileSha1Hash[:])

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapCheck) UnmarshalBinary(data []byte) error {
	if len(data) < 21 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[8:]}

	var err error
	if pkt.FilePath, err = buf.ReadString(); err != nil {
		return err
	}

	if len(data) != 41+len(pkt.FilePath) {
		return ErrWrongSize
	}

	pkt.FileSize = buf.ReadUInt32()
	pkt.MapInfo = buf.ReadUInt32()
	pkt.FileCrcEncryption = buf.ReadUInt32()
	copy(pkt.FileSha1Hash[:], buf.ReadBlob(20))

	return nil
}

// StartDownload implements the [0x3F] W3GS_StartDownload packet (C -> S, S -> C).
//
// C -> S: Client sends this to the host to initiate a map download.
// S -> C: This tells the client that it is now in the downloading state and should expect chunks of file data.
//
// Format:
//
//    (UINT32) Unknown (0x01) [if S -> C]
//    (UINT8) Player number   [if S -> C]
//
type StartDownload struct {
	PlayerID uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *StartDownload) MarshalBinary() ([]byte, error) {
	//if pkt.PlayerID > 0 {
	return []byte{ProtocolSig, PidStartDownload, 9, 0, 0, 0, 0, 0, pkt.PlayerID}, nil
	//}

	//return []byte{protocolsig, PidStartDownload, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *StartDownload) UnmarshalBinary(data []byte) error {
	switch len(data) {
	// case 4:
	// 	pkt.PlayerID = 0
	case 9:
		pkt.PlayerID = data[8]
	default:
		return ErrWrongSize
	}

	return nil
}

// MapSize implements the [0x42] W3GS_MapSize packet (C -> S).
//
// This is sent from the client to tell the host about the map file on the client's local system.
//
// Format:
//
//    (UINT32) Unknown
//    (UINT8) Size Flag
//    (UINT32) Map Size
//
type MapSize struct {
	Ready   bool
	MapSize uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapSize) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 13)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapSize)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt32(0)

	if pkt.Ready {
		buf.WriteUInt8(1)
	} else {
		buf.WriteUInt8(3)
	}

	buf.WriteUInt32(pkt.MapSize)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapSize) UnmarshalBinary(data []byte) error {
	if len(data) != 13 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[8:]}
	pkt.Ready = buf.ReadUInt8() == 1
	pkt.MapSize = buf.ReadUInt32()

	return nil
}

// MapPart implements the [0x43] W3GS_MapPart packet (S -> C).
//
// This is received when you are downloading a map from the host.
//
// You can calculate how many more chunks you have left based on the file size and the chunk position in file. You are done downloading when the chunk position in file (plus the size of the chunk) matches the file size received in 0x42 W3GS_MapSize.
//
// If the data does not match the CRC-32, you should send the host 0x45 W3GS_MapPartError, otherwise you should always send 0x44 W3GS_MapPartOK in reply to this packet.
//
// Format:
//
//    (UINT8) To player number
//    (UINT8) From player number
//    (UINT32) Unknown (0x01)
//    (UINT32) Chunk position in file
//    (UINT32) CRC-32 encryption
//    (UINT8)[1442] Data
//
type MapPart struct {
	RecipientID uint8
	SenderID    uint8
	ChunkPos    uint32
	Data        []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapPart) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 18+len(pkt.Data))}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPart)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt8(pkt.RecipientID)
	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt32(1)
	buf.WriteUInt32(pkt.ChunkPos)

	buf.WriteUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.WriteBlob(pkt.Data)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapPart) UnmarshalBinary(data []byte) error {
	if len(data) < 18 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}

	pkt.RecipientID = buf.ReadUInt8()
	pkt.SenderID = buf.ReadUInt8()
	buf.Skip(4)
	pkt.ChunkPos = buf.ReadUInt32()

	var crc = buf.ReadUInt32()
	pkt.Data = buf.ReadBlob(buf.Size())
	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return ErrInvalidChecksum
	}

	return nil
}

// MapPartOK implements the [0x44] W3GS_MapPartOK packet (C -> S).
//
// The client sends this when it has successfully received a chunk of the map file from the host client.
//
// Format:
//
//    (UINT8) From player number
//    (UINT8) To player number
//    (UINT32) Unknown
//    (UINT32) Chunk position in file
//
type MapPartOK struct {
	SenderID    uint8
	RecipientID uint8
	ChunkPos    uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapPartOK) MarshalBinary() ([]byte, error) {
	var buf = util.PacketBuffer{Bytes: make([]byte, 0, 14)}
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPartOK)

	// Placeholder for packet size
	buf.WriteUInt16(0)

	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt8(pkt.RecipientID)
	buf.WriteUInt32(0)
	buf.WriteUInt32(pkt.ChunkPos)

	// Set packet size
	buf.WriteUInt16At(2, uint16(buf.Size()))

	return buf.Bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapPartOK) UnmarshalBinary(data []byte) error {
	if len(data) != 14 {
		return ErrWrongSize
	}

	var buf = util.PacketBuffer{Bytes: data[4:]}
	pkt.SenderID = buf.ReadUInt8()
	pkt.RecipientID = buf.ReadUInt8()

	buf.Skip(4)
	pkt.ChunkPos = buf.ReadUInt32()

	return nil
}

// MapPartError implements the [0x45] W3GS_MapPartError packet (C -> S).
//
// More research is required.
//
// This is sent when downloading a map in reply to 0x43 W3GS_MapPart and a chunk of the map file does not match its CRC encryption.
//
// Format:
//
//    [unknown]
//
type MapPartError struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapPartError) MarshalBinary() ([]byte, error) {
	return []byte{ProtocolSig, PidMapPartError, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapPartError) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return ErrWrongSize
	}
	return nil
}
