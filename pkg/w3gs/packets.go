package w3gs

import (
	"hash/crc32"

	"github.com/nielsAD/noot/pkg/util"
)

func readPacketHeader(buf *util.PacketBuffer) (byte, int) {
	var bsize = buf.Size()
	if bsize < 4 {
		return 0, -1
	}
	buf.Skip(1)
	var pid = buf.ReadUInt8()
	var psize = int(buf.ReadUInt16())
	if psize > bsize {
		return pid, -1
	}
	return pid, psize
}

func readPacketSize(buf *util.PacketBuffer) int {
	var _, psize = readPacketHeader(buf)
	return psize
}

// UnknownPacket is used to store unknown packets.
type UnknownPacket struct {
	ID   byte
	Blob []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *UnknownPacket) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(pkt.ID)
	buf.WriteUInt16(uint16(4 + len(pkt.Blob)))
	buf.WriteBlob(pkt.Blob)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *UnknownPacket) Deserialize(buf *util.PacketBuffer) error {
	var pid, size = readPacketHeader(buf)
	if size < 4 {
		return ErrWrongSize
	}

	pkt.ID = pid
	pkt.Blob = buf.ReadBlob(size - 4)

	return nil
}

// Ping implements the [0x01] W3GS_PING_FROM_HOST packet (S -> C).
//
// This is sent every 30 seconds to make sure that the client is still responsive.
//
// Format:
//
//    (UINT32) Ping (GetTickCount)
//
type Ping struct {
	Payload uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *Ping) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPingFromHost)
	buf.WriteUInt16(8)
	buf.WriteUInt32(pkt.Payload)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Ping) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 8 {
		return ErrWrongSize
	}

	pkt.Payload = buf.ReadUInt32()

	return nil
}

// Pong implements the [0x46] W3GS_PONG_TO_HOST packet (C -> S).
//
// This is sent in response to 0x01 W3GS_PING_FROM_HOST.
//
// The pong value is just a copy of whatever was sent in SEND_W3GS_PING_FROM_HOST which was GetTicks( ) at the time of sending
// so as long as we trust that the client isn't trying to fake us out and mess with the pong value we can find the round trip time by simple subtraction
// (the subtraction is done elsewhere because the very first pong value seems to be 1 and we want to discard that one)
//
// Format:
//
//    (UINT32) Pong (copy of Ping payload)
//
type Pong struct {
	Ping
}

// Serialize encodes the struct into its binary form.
func (pkt *Pong) Serialize(buf *util.PacketBuffer) error {
	var start = buf.Size()
	if err := pkt.Ping.Serialize(buf); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidPongToHost)
	return nil
}

// PeerPing implements the [0x35] W3GS_PING_FROM_OTHERS packet (C -> C).
//
// Client requests an echo from another client (occurs every 10 seconds).
//
// Format:
//
//    (UINT32) Ping
//    (UINT32) Peer mask  (see [0x37] W3GS_ClientInfo)
//    (UINT32) Game ticks
//
type PeerPing struct {
	Payload   uint32
	PeerMask  uint32
	GameTicks uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerPing) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPingFromOthers)
	buf.WriteUInt16(16)

	buf.WriteUInt32(pkt.Payload)
	buf.WriteUInt32(pkt.PeerMask)
	buf.WriteUInt32(pkt.GameTicks)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PeerPing) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 16 {
		return ErrWrongSize
	}

	pkt.Payload = buf.ReadUInt32()
	pkt.PeerMask = buf.ReadUInt32()
	pkt.GameTicks = buf.ReadUInt32()

	return nil
}

// PeerPong implements the [0x36] W3GS_PONG_TO_OTHERS packet (C -> C).
//
// This is sent in response to an echo from another client.
//
// Format:
//
//    (UINT32) Pong (copy of Ping payload)
//
type PeerPong struct {
	Ping
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerPong) Serialize(buf *util.PacketBuffer) error {
	var start = buf.Size()
	if err := pkt.Ping.Serialize(buf); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidPongToOthers)
	return nil
}

// Join implements the [0x1E] W3GS_ReqJoin packet (C -> S).
//
// A client sends this to the host to enter the game lobby.
//
// The internal IP uses the Windows in_addr structure which is thus used by the sockaddr_in structure.
//
// Format:
//
//    (UINT32)   Host Counter (Game ID)
//    (UINT32)   Entry Key (used in LAN)
//     (UINT8)   Unknown (0x00)
//    (UINT16)   Listen Port
//    (UINT32)   Join counter
//    (STRING)   Player name
//     (UINT8)   Number of bytes that follow (0x01 < 1.29; 0x02 >= 1.29)
//     (UINT8)[] Unknown (0x00)
//    (UINT16)   AF_INET (0x02)
//    (UINT16)   Internal Port
//    (UINT32)   Internal IP
//    (UINT32)   Unknown (0x00)
//    (UINT32)   Unknown (0x00)
//
type Join struct {
	HostCounter  uint32
	EntryKey     uint32
	ListenPort   uint16
	JoinCounter  uint32
	PlayerName   string
	InternalAddr util.SockAddr
}

// Serialize encodes the struct into its binary form.
func (pkt *Join) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidReqJoin)
	buf.WriteUInt16(uint16(38 + len(pkt.PlayerName)))

	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.EntryKey)

	buf.WriteUInt8(0)

	buf.WriteUInt16(pkt.ListenPort)
	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteString(pkt.PlayerName)

	buf.WriteUInt8(1)
	buf.WriteUInt8(0)

	if err := buf.WriteSockAddr(&pkt.InternalAddr); err != nil {
		return err
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Join) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 37 {
		return ErrWrongSize
	}

	pkt.HostCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()

	if buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	pkt.ListenPort = buf.ReadUInt16()
	pkt.JoinCounter = buf.ReadUInt32()

	var err error
	if pkt.PlayerName, err = buf.ReadString(); err != nil {
		return err
	}

	if size < 37+len(pkt.PlayerName) {
		return ErrWrongSize
	}

	var skip = int(buf.ReadUInt8())
	if size != 37+len(pkt.PlayerName)+skip {
		return ErrWrongSize
	}
	buf.Skip(skip)

	if pkt.InternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}

	return nil
}

// RejectJoin implements the [0x05] W3GS_RejectJoin packet (S -> C).
//
// This is sent in a response to a request to join the game lobby and indicates that the request was denied.
//
// Reason:
//
//    0x09 RejectJoin_FULL      The game lobby is full
//    0x07 RejectJoin_INVALID   There was an error in your request
//    0x10 RejectJoin_STARTED   The game has already been started
//    0x27 RejectJoin_WRONGPASS The password you sent was incorrect
//
// Format:
//
//    (UINT32) Reason
//
type RejectJoin struct {
	Reason uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *RejectJoin) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidRejectJoin)
	buf.WriteUInt16(8)
	buf.WriteUInt32(pkt.Reason)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *RejectJoin) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 8 {
		return ErrWrongSize
	}

	pkt.Reason = buf.ReadUInt32()

	return nil
}

// SlotInfoJoin implements the [0x04] W3GS_SlotInfoJoin packet (S -> C).
//
// This is sent to tell the client about the game slots, upon entry of the lobby.
//
// Format:
//
//    Embedded [0x09] W3GS_SlotInfo:
//	    (UINT16)   Length of Slot data
//	     (UINT8)   Number of slots
//	     (UINT8)[] Slot data
//	    (UINT32)   Random seed
//	     (UINT8)   Slots layout
//	     (UINT8)   Number of player slots without observers
//
//     (UINT8) Player number
//    (UINT16) AF_INET (0x02)
//    (UINT16) Port
//    (UINT32) External IP
//    (UINT32) Unknown (0x00)
//    (UINT32) Unknown (0x00)
//
type SlotInfoJoin struct {
	SlotInfo
	PlayerID     uint8
	ExternalAddr util.SockAddr
}

// Serialize encodes the struct into its binary form.
func (pkt *SlotInfoJoin) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSlotInfoJoin)
	buf.WriteUInt16(uint16(30 + len(pkt.Slots)*9))

	pkt.SlotInfo.serialize(buf)
	buf.WriteUInt8(pkt.PlayerID)

	if err := buf.WriteSockAddr(&pkt.ExternalAddr); err != nil {
		return err
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *SlotInfoJoin) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 30 {
		return ErrWrongSize
	}

	if err := pkt.SlotInfo.deserialize(buf); err != nil {
		return err
	}

	if size != 30+len(pkt.Slots)*9 {
		return ErrWrongSize
	}

	pkt.PlayerID = buf.ReadUInt8()

	var err error
	if pkt.ExternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}

	return nil
}

// SlotInfo implements the [0x09] W3GS_SlotInfo packet (S -> C).
//
// This is sent for slot updates.
//
// The length of slot info should always be `0x0B`.
//
// Format:
//
//    (UINT16)   Length of Slot data
//     (UINT8)   Number of slots
//     (UINT8)[] Slot data
//    (UINT32)   Random seed
//     (UINT8)   Slots layout
//     (UINT8)   Number of player slots without observers
//
//    For each slot:
//       (UINT8) Player number
//       (UINT8) Download status
//       (UINT8) Slot status
//       (UINT8) Computer status
//       (UINT8) Team
//       (UINT8) Color
//       (UINT8) Race
//       (UINT8) Computer type
//       (UINT8) Handicap
//
type SlotInfo struct {
	Slots      []SlotData
	RandomSeed uint32
	SlotLayout uint8
	NumPlayers uint8
}

// SlotData stores the info for a single game slot.
//
// **Download status:**
//
// - This is a percentage of their download progress. As such, this value can only be between 0 and 100.
//
// Slot status:
//
//    0x00 Open
//    0x01 Closed
//    0x02 Occupied
//
// Computer status:
//
//    0x00 Human
//    0x01 Computer
//
// Race:
//
//    0x01 Human
//    0x02 Orc
//    0x04 Night Elf
//    0x08 Undead
//    0x20 Random
//    0x40 Selectable
//
// Computer type:
//
//    0x00 Easy
//    0x01 Normal / Human
//    0x02 Hard
//
//    (UINT8) Player number
//    (UINT8) Download status
//    (UINT8) Slot status
//    (UINT8) Computer status
//    (UINT8) Team
//    (UINT8) Color
//    (UINT8) Race
//    (UINT8) Computer type
//    (UINT8) Handicap
//
type SlotData struct {
	PlayerID       uint8
	DownloadStatus uint8
	SlotStatus     uint8
	Computer       bool
	Team           uint8
	Color          uint8
	Race           uint8
	ComputerType   uint8
	Handicap       uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *SlotInfo) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSlotInfo)
	buf.WriteUInt16(uint16(13 + len(pkt.Slots)*9))

	pkt.serialize(buf)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *SlotInfo) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 13 {
		return ErrWrongSize
	}

	if err := pkt.deserialize(buf); err != nil {
		return err
	}

	if size != 13+len(pkt.Slots)*9 {
		return ErrWrongSize
	}

	return nil
}

func (pkt *SlotInfo) serialize(buf *util.PacketBuffer) {
	buf.WriteUInt16(uint16(7 + len(pkt.Slots)*9))
	buf.WriteUInt8(uint8(len(pkt.Slots)))

	for i := 0; i < len(pkt.Slots); i++ {
		buf.WriteUInt8(pkt.Slots[i].PlayerID)
		buf.WriteUInt8(pkt.Slots[i].DownloadStatus)
		buf.WriteUInt8(pkt.Slots[i].SlotStatus)
		buf.WriteBool(pkt.Slots[i].Computer)
		buf.WriteUInt8(pkt.Slots[i].Team)
		buf.WriteUInt8(pkt.Slots[i].Color)
		buf.WriteUInt8(pkt.Slots[i].Race)
		buf.WriteUInt8(pkt.Slots[i].ComputerType)
		buf.WriteUInt8(pkt.Slots[i].Handicap)
	}

	buf.WriteUInt32(pkt.RandomSeed)
	buf.WriteUInt8(pkt.SlotLayout)
	buf.WriteUInt8(pkt.NumPlayers)
}

func (pkt *SlotInfo) deserialize(buf *util.PacketBuffer) error {
	var slotSize = int(buf.ReadUInt16())
	var numSlots = int(buf.ReadUInt8())

	if buf.Size()+1 < slotSize || slotSize != 7+numSlots*9 {
		return ErrWrongSize
	}

	if cap(pkt.Slots) < numSlots {
		pkt.Slots = make([]SlotData, 0, numSlots)
	}
	pkt.Slots = pkt.Slots[:numSlots]

	for i := 0; i < len(pkt.Slots); i++ {
		pkt.Slots[i].PlayerID = buf.ReadUInt8()
		pkt.Slots[i].DownloadStatus = buf.ReadUInt8()
		pkt.Slots[i].SlotStatus = buf.ReadUInt8()
		pkt.Slots[i].Computer = buf.ReadBool()
		pkt.Slots[i].Team = buf.ReadUInt8()
		pkt.Slots[i].Color = buf.ReadUInt8()
		pkt.Slots[i].Race = buf.ReadUInt8()
		pkt.Slots[i].ComputerType = buf.ReadUInt8()
		pkt.Slots[i].Handicap = buf.ReadUInt8()
	}

	pkt.RandomSeed = buf.ReadUInt32()
	pkt.SlotLayout = buf.ReadUInt8()
	pkt.NumPlayers = buf.ReadUInt8()

	return nil
}

// PlayerInfo implements the [0x06] W3GS_PlayerInfo packet (S -> C).
//
// Tells a client about a player's information.
//
// The external and internal IP are always zero for the host.
//
// Format:
//
//    (UINT32)   Join Counter
//     (UINT8)   Player number
//    (STRING)   Player name
//     (UINT8)   Number of bytes that follow (0x01)
//     (UINT8)[] Unknown (0x00)
//    (UINT16)   AF_INET (0x02)
//    (UINT16)   Port
//    (UINT32)   External IP
//    (UINT32)   Unknown (0x00)
//    (UINT32)   Unknown (0x00)
//    (UINT16)   AF_INET (0x02)
//    (UINT16)   Port
//    (UINT32)   Internal IP
//    (UINT32)   Unknown (0x00)
//    (UINT32)   Unknown (0x00)
//
type PlayerInfo struct {
	JoinCounter  uint32
	PlayerID     uint8
	PlayerName   string
	ExternalAddr util.SockAddr
	InternalAddr util.SockAddr
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerInfo) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerInfo)
	buf.WriteUInt16(uint16(44 + len(pkt.PlayerName)))

	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteUInt8(pkt.PlayerID)
	buf.WriteString(pkt.PlayerName)

	buf.WriteUInt8(1)
	buf.WriteUInt8(0)

	if err := buf.WriteSockAddr(&pkt.ExternalAddr); err != nil {
		return err
	}
	if err := buf.WriteSockAddr(&pkt.InternalAddr); err != nil {
		return err
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PlayerInfo) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 43 {
		return ErrWrongSize
	}

	pkt.JoinCounter = buf.ReadUInt32()
	pkt.PlayerID = buf.ReadUInt8()

	var err error
	if pkt.PlayerName, err = buf.ReadString(); err != nil {
		return err
	}
	if size < 43+len(pkt.PlayerName) {
		return ErrWrongSize
	}

	var skip = int(buf.ReadUInt8())
	if size != 43+len(pkt.PlayerName)+skip {
		return ErrWrongSize
	}
	buf.Skip(skip)

	if pkt.ExternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}
	if pkt.InternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}

	return nil
}

// Leave implements the [0x21] W3GS_LeaveReq packet (C -> S).
//
// A client requests to leave.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT32) Reason
//
type Leave struct {
	Reason uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *Leave) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidLeaveReq)
	buf.WriteUInt16(8)
	buf.WriteUInt32(pkt.Reason)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Leave) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 8 {
		return ErrWrongSize
	}

	pkt.Reason = buf.ReadUInt32()
	return nil
}

// PlayerKicked implements the [0x1C] W3GS_PlayerKicked packet (S -> C).
//
// The host has kicked the client from the lobby.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT32) Reason
//
type PlayerKicked struct {
	Leave
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerKicked) Serialize(buf *util.PacketBuffer) error {
	var start = buf.Size()
	if err := pkt.Leave.Serialize(buf); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidPlayerKicked)
	return nil
}

// LeaveAck implements the [0x1B] W3GS_LeaveAck packet (S -> C).
//
// This is the response to [0x21] W3GS_LeaveReq.
//
// You will leave the game once the connection is terminated.
//
// Format:
//
//    [blank]
//
type LeaveAck struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *LeaveAck) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidLeaveAck)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *LeaveAck) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 4 {
		return ErrWrongSize
	}
	return nil
}

// PlayerLeft implements the [0x07] W3GS_PlayerLeft packet (S -> C).
//
// This is received from the game host when a player leaves.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//     (UINT8) Player number
//    (UINT32) Reason
//
type PlayerLeft struct {
	PlayerID uint8
	Reason   uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerLeft) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerLeft)
	buf.WriteUInt16(9)
	buf.WriteUInt8(pkt.PlayerID)
	buf.WriteUInt32(pkt.Reason)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PlayerLeft) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 9 {
		return ErrWrongSize
	}

	pkt.PlayerID = buf.ReadUInt8()
	pkt.Reason = buf.ReadUInt32()
	return nil
}

// CountDownStart implements the [0x0A] W3GS_COUNTDOWN_START packet (S -> C).
//
// The game has begun the countdown to start.
//
// The official clients countdown from 5 seconds, however it is possible to use any time you wish. For example, the GHost++ bot uses 10 seconds when auto-hosted, but 5 seconds when started using an administrative command.
//
// Format:
//
//    [blank]
//
type CountDownStart struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *CountDownStart) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidCountDownStart)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *CountDownStart) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 4 {
		return ErrWrongSize
	}
	return nil
}

// CountDownEnd implements the [0x0B] W3GS_COUNTDOWN_END packet (S -> C).
//
// The game has finished the countdown and has now started. Players should see a loading screen for the map once this is received.
//
// [0x0A] W3GS_COUNTDOWN_START should be received before this packet, even if there is no countdown or if the countdown was 0 seconds.
//
// Format:
//
//    [blank]
//
type CountDownEnd struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *CountDownEnd) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidCountDownEnd)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *CountDownEnd) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 4 {
		return ErrWrongSize
	}
	return nil
}

// GameLoaded implements the [0x23] W3GS_GAMELOADED_SELF packet (C -> S).
//
// The client sends this to the host when they have finished loading the map.
//
// Format:
//
//    [blank]
//
type GameLoaded struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *GameLoaded) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGameLoadedSelf)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameLoaded) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 4 {
		return ErrWrongSize
	}
	return nil
}

// PlayerLoaded implements the [0x08] W3GS_PlayerLoaded packet (S -> C).
//
// Sent to all other clients in-game to notify that a player has finished loading.
//
// Format:
//
//    (UINT8) Player number
//
type PlayerLoaded struct {
	PlayerID uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerLoaded) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerLoaded)
	buf.WriteUInt16(5)
	buf.WriteUInt8(pkt.PlayerID)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PlayerLoaded) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 5 {
		return ErrWrongSize
	}

	pkt.PlayerID = buf.ReadUInt8()
	return nil
}

// GameOver implements the [0x14] W3GS_GameOver packet (S -> C).
//
// Notify clients that the game has ended and the connection will be closed.
//
// Format:
//
//    (UINT8) Player number
//
type GameOver struct {
	PlayerID uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *GameOver) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGameOver)
	buf.WriteUInt16(5)
	buf.WriteUInt8(pkt.PlayerID)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameOver) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 5 {
		return ErrWrongSize
	}

	pkt.PlayerID = buf.ReadUInt8()
	return nil
}

// StartLag implements the [0x10] W3GS_START_LAG packet (S -> C).
//
// This is sent to the clients to initiate the lag screen.
//
// Format:
//
//    (UINT8) Number of lagging players
//
//    For every lagging player:
//        (UINT8) Player number
//       (UINT32) Lag duration in milliseconds
//
type StartLag struct {
	Players []LagPlayer
}

// Serialize encodes the struct into its binary form.
func (pkt *StartLag) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStartLag)
	buf.WriteUInt16(uint16(5 + len(pkt.Players)*5))

	buf.WriteUInt8(uint8(len(pkt.Players)))
	for i := 0; i < len(pkt.Players); i++ {
		pkt.Players[i].serialize(buf)
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StartLag) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 5 {
		return ErrWrongSize
	}

	var numPlayers = int(buf.ReadUInt8())

	if size != 5+numPlayers*5 {
		return ErrWrongSize
	}

	if cap(pkt.Players) < numPlayers {
		pkt.Players = make([]LagPlayer, 0, numPlayers)
	}
	pkt.Players = pkt.Players[:numPlayers]

	for i := 0; i < len(pkt.Players); i++ {
		pkt.Players[i].deserialize(buf)
	}

	return nil
}

// LagPlayer stores the data for a single lagging player.
//
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type LagPlayer struct {
	PlayerID      uint8
	LagDurationMS uint32
}

func (lp *LagPlayer) serialize(buf *util.PacketBuffer) {
	buf.WriteUInt8(lp.PlayerID)
	buf.WriteUInt32(lp.LagDurationMS)
}

func (lp *LagPlayer) deserialize(buf *util.PacketBuffer) {
	lp.PlayerID = buf.ReadUInt8()
	lp.LagDurationMS = buf.ReadUInt32()
}

// StopLag implements the [0x11] W3GS_STOP_LAG packet (S -> C).
//
// This is sent to the clients to indicate that a player stopped lagging.
//
// Format:
//
//     (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type StopLag struct {
	LagPlayer
}

// Serialize encodes the struct into its binary form.
func (pkt *StopLag) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStopLag)
	buf.WriteUInt16(9)

	pkt.LagPlayer.serialize(buf)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StopLag) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 9 {
		return ErrWrongSize
	}

	pkt.LagPlayer.deserialize(buf)
	return nil
}

// DropLaggers implements the [0x2F] W3GS_STOP_DROPREQ packet (C -> S).
//
// This is sent when a player votes to drop lagging players.
//
// Format:
//
//    [blank]
//
type DropLaggers struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *DropLaggers) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidDropReq)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *DropLaggers) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 4 {
		return ErrWrongSize
	}
	return nil
}

// GameAction implements the [0x26] W3GS_OUTGOING_ACTION packet (C -> S).
//
// A client sends this to the game host to execute an action in-game.
//
// Format:
//
//    (UINT32) CRC-32 checksum
//      (VOID) Action data
//
type GameAction struct {
	Data []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *GameAction) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidOutgoingAction)
	buf.WriteUInt16(uint16(8 + len(pkt.Data)))

	buf.WriteUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.WriteBlob(pkt.Data)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameAction) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 8 {
		return ErrWrongSize
	}

	var crc = buf.ReadUInt32()
	pkt.Data = buf.ReadBlob(size - 8)

	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return ErrInvalidChecksum
	}

	return nil
}

// TimeSlot implements the [0x0C] W3GS_INCOMING_ACTION packet (S -> C).
//
// Informs the client about an action in-game.
//
// Format:
//
//    (UINT16) Send interval
//    (UINT16) CRC-16 encryption
//
//    For each action:
//        (UINT8) Player number
//       (UINT16) Length of action data
//         (VOID) Action data
//
type TimeSlot struct {
	Fragment        bool
	TimeIncrementMS uint16
	crc             uint16
	Actions         []PlayerAction
}

// PlayerAction stores the data for a single game action.
//
//    (UINT8) Player number
//    (UINT16) Length of action data
//    (VOID) Action data
//
type PlayerAction struct {
	PlayerID uint8
	Data     []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *TimeSlot) Serialize(buf *util.PacketBuffer) error {
	var start = buf.Size()
	buf.WriteUInt8(ProtocolSig)

	if pkt.Fragment {
		buf.WriteUInt8(PidIncomingAction2)
	} else {
		buf.WriteUInt8(PidIncomingAction)
	}

	// Placeholder for size
	buf.WriteUInt16(0)

	buf.WriteUInt16(pkt.TimeIncrementMS)

	// Placeholder for CRC
	buf.WriteUInt16(0)

	for i := 0; i < len(pkt.Actions); i++ {
		buf.WriteUInt8(pkt.Actions[i].PlayerID)
		buf.WriteUInt16(uint16(len(pkt.Actions[i].Data)))
		buf.WriteBlob(pkt.Actions[i].Data)
	}

	// Set size
	buf.WriteUInt16At(start+2, uint16(buf.Size()-start))

	// Set CRC
	buf.WriteUInt16At(start+6, uint16(crc32.ChecksumIEEE(buf.Bytes[start+8:])))

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *TimeSlot) Deserialize(buf *util.PacketBuffer) error {
	var pid, size = readPacketHeader(buf)
	if size < 6 {
		return ErrWrongSize
	}

	pkt.Fragment = pid == PidIncomingAction2
	pkt.TimeIncrementMS = buf.ReadUInt16()

	if size == 6 {
		pkt.Actions = nil
		return nil
	} else if size < 8 {
		return ErrWrongSize
	}

	size -= 8

	var crc = buf.ReadUInt16()
	if crc != uint16(crc32.ChecksumIEEE(buf.Bytes[:size])) {
		return ErrInvalidChecksum
	}

	pkt.Actions = pkt.Actions[:0]
	for size > 3 {
		var action = PlayerAction{
			PlayerID: buf.ReadUInt8(),
		}

		var subsize = int(buf.ReadUInt16())
		if size < subsize {
			return ErrMalformedData
		}
		size -= 3 + subsize

		action.Data = buf.ReadBlob(subsize)
		pkt.Actions = append(pkt.Actions, action)
	}

	if size != 0 {
		return ErrWrongSize
	}

	return nil
}

// TimeSlotAck implements the [0x27] W3GS_OUTGOING_KEEPALIVE packet (C -> S).
//
// This is sent to the host from each client.
//
// Format:
//
//    (UINT8)  Unknown
//    (UINT32) Unknown (checksum?)
//
type TimeSlotAck struct {
	Unknown1 uint8
	Checksum uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *TimeSlotAck) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidOutgoingKeepAlive)
	buf.WriteUInt16(9)
	buf.WriteUInt8(pkt.Unknown1)
	buf.WriteUInt32(pkt.Checksum)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *TimeSlotAck) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 9 {
		return ErrWrongSize
	}

	pkt.Unknown1 = buf.ReadUInt8()
	pkt.Checksum = buf.ReadUInt32()
	return nil
}

// Desync implements the [0x0D] W3GS_DESYNC packet (S -> C).
//
// This is sent whenever the server detects a split state based on checksums sent
// by [0x27] W3GS_OUTGOING_KEEPALIVE. Each client continues the game with the
// given player numbers, other players are dropped.
//
//    (UINT32)  Unknown (0x01)
//    (UINT8)   Unknown (0x04)
//    (UINT32)  Checksum
//    (UINT8)   NumPlayersInState
//    (UINT8)[] Player numbers
//
type Desync struct {
	Checksum       uint32
	PlayersInState []uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *Desync) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidDesync)
	buf.WriteUInt16(uint16(14 + len(pkt.PlayersInState)))
	buf.WriteUInt32(1)
	buf.WriteUInt8(4)
	buf.WriteUInt32(pkt.Checksum)
	buf.WriteUInt8(uint8(len(pkt.PlayersInState)))
	buf.WriteBlob(pkt.PlayersInState)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Desync) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 14 {
		return ErrWrongSize
	}

	if buf.ReadUInt32() != 1 || buf.ReadUInt8() != 4 {
		return ErrUnexpectedConst
	}
	pkt.Checksum = buf.ReadUInt32()

	var numPlayers = int(buf.ReadUInt8())
	if size != 14+numPlayers {
		return ErrWrongSize
	}

	pkt.PlayersInState = buf.ReadBlob(numPlayers)

	return nil
}

// Message implements the [0x28] W3GS_CHAT_TO_HOST packet (C -> S).
//
// This is sent from the client to the host to send a message to the other clients.
//
// Format:
//
//    (UINT8)   Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8)   From player number
//    (UINT8)   Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type Message struct {
	RecipientIDs []uint8
	SenderID     uint8
	Flags        uint8
	NewVal       uint8
	ExtraFlags   uint32
	Content      string
}

// Serialize encodes the struct into its binary form.
func (pkt *Message) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidChatToHost)

	switch pkt.Flags {
	case ChatMessageExtra:
		buf.WriteUInt16(uint16(12 + len(pkt.RecipientIDs) + len(pkt.Content)))
	case ChatMessage:
		buf.WriteUInt16(uint16(8 + len(pkt.RecipientIDs) + len(pkt.Content)))
	default:
		buf.WriteUInt16(uint16(8 + len(pkt.RecipientIDs)))
	}

	buf.WriteUInt8(uint8(len(pkt.RecipientIDs)))
	buf.WriteBlob(pkt.RecipientIDs)
	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt8(pkt.Flags)

	switch pkt.Flags {
	case ChatMessageExtra:
		buf.WriteUInt32(pkt.ExtraFlags)
		fallthrough
	case ChatMessage:
		buf.WriteString(pkt.Content)
	default:
		buf.WriteUInt8(pkt.NewVal)
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Message) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 8 {
		return ErrWrongSize
	}

	var numRecipients = int(buf.ReadUInt8())
	if size < 8+numRecipients {
		return ErrWrongSize
	}

	pkt.RecipientIDs = buf.ReadBlob(numRecipients)
	pkt.SenderID = buf.ReadUInt8()
	pkt.Flags = buf.ReadUInt8()

	pkt.NewVal = 0
	pkt.ExtraFlags = 0
	pkt.Content = ""

	switch pkt.Flags {
	case ChatMessageExtra:
		if size < 12+numRecipients {
			return ErrWrongSize
		}
		size -= 4
		pkt.ExtraFlags = buf.ReadUInt32()
		fallthrough
	case ChatMessage:
		var err error
		if pkt.Content, err = buf.ReadString(); err != nil {
			return err
		}
		if size != 8+numRecipients+len(pkt.Content) {
			return ErrWrongSize
		}
	default:
		if size != 8+numRecipients {
			return ErrWrongSize
		}
		pkt.NewVal = buf.ReadUInt8()
	}

	return nil
}

// MessageRelay implements the [0x0F] W3GS_CHAT_FROM_HOST packet (S -> C).
//
// This is sent to the clients to print a message on the screen from another player.
//
// Format:
//
//    (UINT8)   Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8)   From player number
//    (UINT8)   Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type MessageRelay struct {
	Message
}

// Serialize encodes the struct into its binary form.
func (pkt *MessageRelay) Serialize(buf *util.PacketBuffer) error {
	var start = buf.Size()
	if err := pkt.Message.Serialize(buf); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidChatFromHost)
	return nil
}

// PeerMessage implements the [0x34] W3GS_CHAT_FROM_OTHERS packet (S -> C).
//
// This is sent to connected peers to print a message on the screen from another player.
//
// Format:
//
//    (UINT8)   Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8)   From player number
//    (UINT8)   Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type PeerMessage struct {
	Message
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerMessage) Serialize(buf *util.PacketBuffer) error {
	var start = buf.Size()
	if err := pkt.Message.Serialize(buf); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidChatFromOthers)
	return nil
}

// SearchGame implements the [0x2F] W3GS_SearchGame packet (C -> S).
//
// This is broadcasted to the entire local area network to detect games during initial
// search of local games. After that, it is sent directly to clients that broadcasted
// [0x31] W3GS_CreateGame (counter is increased for every direct message).
//
// Product is either WAR3 or W3XP.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Counter
//
type SearchGame struct {
	GameVersion
	Counter uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *SearchGame) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSearchGame)
	buf.WriteUInt16(16)

	pkt.GameVersion.serialize(buf)
	buf.WriteUInt32(pkt.Counter)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *SearchGame) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 16 {
		return ErrWrongSize
	}

	if err := pkt.GameVersion.deserialize(buf); err != nil {
		return err
	}

	pkt.Counter = buf.ReadUInt32()

	return nil
}

// GameVersion stores the game version tuple.
//
//    (UINT32) Product
//    (UINT32) Version
//
type GameVersion struct {
	TFT     bool
	Version uint32
}

// Game versions
var (
	gameW3DM = "MD3W" // Demo
	gameWAR3 = "3RAW" // ROC
	gameW3XP = "PX3W" // TFT
)

func (gv *GameVersion) serialize(buf *util.PacketBuffer) {
	if gv.TFT {
		buf.WriteBlob([]byte(gameW3XP))
	} else {
		buf.WriteBlob([]byte(gameWAR3))
	}
	buf.WriteUInt32(gv.Version)
}

func (gv *GameVersion) deserialize(buf *util.PacketBuffer) error {
	switch string(buf.ReadBlob(4)) {
	case gameW3XP:
		gv.TFT = true
	case gameWAR3:
		gv.TFT = false
	default:
		return ErrUnexpectedConst
	}
	gv.Version = buf.ReadUInt32()
	return nil
}

// GameInfo implements the [0x30] W3GS_GameInfo packet (S -> C).
//
// This is sent in response to [0x2F] W3GS_SearchGame (on the local area network).
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Host Counter
//    (UINT32) Entry key
//    (STRING) Game name
//     (UINT8) Unknown (0x00)
//    (STRING) Statstring
//    (UINT32) Slots total
//    (UINT32) Game Type Info
//    (UINT32) Player slots used
//    (UINT32) Player slots available (total slots - closed slots - AI slots)
//    (UINT32) Time since creation
//    (UINT16) Listen Port
//
type GameInfo struct {
	GameVersion
	HostCounter    uint32
	EntryKey       uint32
	GameName       string
	StatString     string
	SlotsTotal     uint32
	GameTypeFlags  uint32
	SlotsUsed      uint32
	SlotsAvailable uint32
	UptimeSec      uint32
	GamePort       uint16
}

// Serialize encodes the struct into its binary form.
func (pkt *GameInfo) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGameInfo)
	buf.WriteUInt16(uint16(45 + len(pkt.GameName) + len(pkt.StatString)))

	pkt.GameVersion.serialize(buf)
	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.EntryKey)
	buf.WriteString(pkt.GameName)
	buf.WriteUInt8(0)
	buf.WriteString(pkt.StatString)
	buf.WriteUInt32(pkt.SlotsTotal)
	buf.WriteUInt32(pkt.GameTypeFlags)
	buf.WriteUInt32(pkt.SlotsUsed)
	buf.WriteUInt32(pkt.SlotsAvailable)
	buf.WriteUInt32(pkt.UptimeSec)
	buf.WriteUInt16(pkt.GamePort)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameInfo) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 45 {
		return ErrWrongSize
	}

	if err := pkt.GameVersion.deserialize(buf); err != nil {
		return err
	}

	pkt.HostCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()

	var err error
	if pkt.GameName, err = buf.ReadString(); err != nil {
		return err
	}
	if size < 45+len(pkt.GameName) {
		return ErrWrongSize
	}

	if buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	if pkt.StatString, err = buf.ReadString(); err != nil {
		return err
	}
	if size < 45+len(pkt.GameName)+len(pkt.StatString) {
		return ErrWrongSize
	}

	pkt.SlotsTotal = buf.ReadUInt32()
	pkt.GameTypeFlags = buf.ReadUInt32()
	pkt.SlotsUsed = buf.ReadUInt32()
	pkt.SlotsAvailable = buf.ReadUInt32()
	pkt.UptimeSec = buf.ReadUInt32()
	pkt.GamePort = buf.ReadUInt16()

	return nil
}

// CreateGame implements the [0x31] W3GS_CreateGame packet (S -> C).
//
// Notifies the local area network that a game was created.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) HostCounter
//
type CreateGame struct {
	GameVersion
	HostCounter uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *CreateGame) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidCreateGame)
	buf.WriteUInt16(16)

	pkt.GameVersion.serialize(buf)
	buf.WriteUInt32(pkt.HostCounter)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *CreateGame) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 16 {
		return ErrWrongSize
	}

	if err := pkt.GameVersion.deserialize(buf); err != nil {
		return err
	}

	pkt.HostCounter = buf.ReadUInt32()

	return nil
}

// RefreshGame implements the [0x32] W3GS_RefreshGame packet (S -> C).
//
// Notifies the local area network about a game (occurs every 5 seconds or refresh slots).
//
// Format:
//
//    (UINT32) Host Counter
//    (UINT32) Player slots used
//    (UINT32) Player slots available (total slots - closed slots - AI slots)
//
type RefreshGame struct {
	HostCounter    uint32
	SlotsUsed      uint32
	SlotsAvailable uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *RefreshGame) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidRefreshGame)
	buf.WriteUInt16(16)

	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.SlotsUsed)
	buf.WriteUInt32(pkt.SlotsAvailable)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *RefreshGame) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 16 {
		return ErrWrongSize
	}

	pkt.HostCounter = buf.ReadUInt32()
	pkt.SlotsUsed = buf.ReadUInt32()
	pkt.SlotsAvailable = buf.ReadUInt32()

	return nil
}

// DecreateGame implements the [0x33] W3GS_DecreateGame packet (S -> C).
//
// Notifies the local area network that a game is no longer being hosted.
//
// Format:
//
//    (UINT32) Host Counter
//
type DecreateGame struct {
	HostCounter uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *DecreateGame) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidDecreateGame)
	buf.WriteUInt16(8)
	buf.WriteUInt32(pkt.HostCounter)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *DecreateGame) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 8 {
		return ErrWrongSize
	}

	pkt.HostCounter = buf.ReadUInt32()
	return nil
}

// PeerConnect implements the [0x37] W3GS_ClientInfo packet (C -> S).
//
// A client sends this to another client to gain information about self when connected.
//
// Peer Mask is a bit mask with bits set for every peer connected to this client.
//
// Format:
//
//    (UINT32) Player Counter
//    (UINT32) Entry key
//     (UINT8) Player number
//     (UINT8) Unknown (0xFF, status?)
//    (UINT32) Peer Mask
//
type PeerConnect struct {
	JoinCounter uint32
	EntryKey    uint32
	PlayerID    uint8
	PeerMask    uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerConnect) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidClientInfo)
	buf.WriteUInt16(18)

	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteUInt32(pkt.EntryKey)
	buf.WriteUInt8(pkt.PlayerID)

	buf.WriteUInt8(0xFF)
	buf.WriteUInt32(pkt.PeerMask)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PeerConnect) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 18 {
		return ErrWrongSize
	}

	pkt.JoinCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()
	pkt.PlayerID = buf.ReadUInt8()

	if buf.ReadUInt8() != 0xFF {
		return ErrUnexpectedConst
	}

	pkt.PeerMask = buf.ReadUInt32()

	return nil
}

// PeerMask implements the [0x3B] W3GS_PEER_MASK packet (C -> C).
//
// Client sends this to the server to let it know which peers are connected to the client.
//
// Format:
//
//    (UINT16) Peer Mask
//
type PeerMask struct {
	PeerMask uint16
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerMask) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPeerMask)
	buf.WriteUInt16(6)

	buf.WriteUInt16(pkt.PeerMask)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PeerMask) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 6 {
		return ErrWrongSize
	}

	pkt.PeerMask = buf.ReadUInt16()

	return nil
}

// MapCheck implements the [0x3D] W3GS_MapCheck packet (S -> C).
//
// This is sent from the game host to a client that just joined to check if the client has the map.
//
// The map info is the actual CRC and the other CRC is actually an "xoro" value.
//
// Format:
//
//    (UINT32)     Unknown (0x01)
//    (STRING)     File Path
//    (UINT32)     File size
//    (UINT32)     Map info
//    (UINT32)     File CRC encryption
//     (UINT8)[20] File SHA-1 hash
//
type MapCheck struct {
	FilePath          string
	FileSize          uint32
	MapInfo           uint32
	FileCrcEncryption uint32
	FileSha1Hash      [20]byte
}

// Serialize encodes the struct into its binary form.
func (pkt *MapCheck) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapCheck)
	buf.WriteUInt16(uint16(41 + len(pkt.FilePath)))

	buf.WriteUInt32(1)
	buf.WriteString(pkt.FilePath)
	buf.WriteUInt32(pkt.FileSize)
	buf.WriteUInt32(pkt.MapInfo)
	buf.WriteUInt32(pkt.FileCrcEncryption)
	buf.WriteBlob(pkt.FileSha1Hash[:])

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapCheck) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 41 {
		return ErrWrongSize
	}

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}

	var err error
	if pkt.FilePath, err = buf.ReadString(); err != nil {
		return err
	}

	if size < 41+len(pkt.FilePath) {
		return ErrWrongSize
	}

	pkt.FileSize = buf.ReadUInt32()
	pkt.MapInfo = buf.ReadUInt32()
	pkt.FileCrcEncryption = buf.ReadUInt32()
	copy(pkt.FileSha1Hash[:], buf.ReadBlob(20))

	return nil
}

// StartDownload implements the [0x3F] W3GS_StartDownload packet (C -> S, S -> C).
//
// C -> S: Client sends this to the host to initiate a map download.
// S -> C: This tells the client that it is now in the downloading state and should expect chunks of file data.
//
// Format:
//
//    (UINT32) Unknown (0x01)
//     (UINT8) Player number
//
type StartDownload struct {
	PlayerID uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *StartDownload) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStartDownload)
	buf.WriteUInt16(9)
	buf.WriteUInt32(1)
	buf.WriteUInt8(pkt.PlayerID)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StartDownload) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 9 {
		return ErrWrongSize
	}

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}
	pkt.PlayerID = buf.ReadUInt8()

	return nil
}

// MapState implements the [0x42] W3GS_MapSize packet (C -> S).
//
// This is sent from the client to tell the host about the map file on the client's local system.
//
// Format:
//
//    (UINT32) Unknown (0x01)
//     (UINT8) Size Flag (0x01 is ready, 0x03 to request the next 0x43] W3GS_MapPart)
//    (UINT32) Map Size
//
type MapState struct {
	Ready    bool
	FileSize uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *MapState) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapSize)
	buf.WriteUInt16(13)

	buf.WriteUInt32(1)

	if pkt.Ready {
		buf.WriteUInt8(1)
	} else {
		buf.WriteUInt8(3)
	}

	buf.WriteUInt32(pkt.FileSize)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapState) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 13 {
		return ErrWrongSize
	}

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}
	pkt.Ready = buf.ReadUInt8() == 1
	pkt.FileSize = buf.ReadUInt32()

	return nil
}

// MapPart implements the [0x43] W3GS_MapPart packet (S -> C).
//
// This is received when you are downloading a map from the host.
//
// You can calculate how many more chunks you have left based on the file size and the chunk position in file. You are done downloading when the chunk position in file (plus the size of the chunk) matches the file size received in 0x42 W3GS_MapSize.
//
// If the data does not match the CRC-32, you should send the host 0x45 W3GS_MapPartError, otherwise you should always send 0x44 W3GS_MapPartOK in reply to this packet.
//
// Format:
//
//     (UINT8)       To player number
//     (UINT8)       From player number
//    (UINT32)       Unknown (0x01)
//    (UINT32)       Chunk position in file
//    (UINT32)       CRC-32 encryption
//     (UINT8)[1442] Data
//
type MapPart struct {
	RecipientID uint8
	SenderID    uint8
	ChunkPos    uint32
	Data        []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *MapPart) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPart)
	buf.WriteUInt16(uint16(18 + len(pkt.Data)))

	buf.WriteUInt8(pkt.RecipientID)
	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt32(1)
	buf.WriteUInt32(pkt.ChunkPos)

	buf.WriteUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.WriteBlob(pkt.Data)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapPart) Deserialize(buf *util.PacketBuffer) error {
	var size = readPacketSize(buf)
	if size < 18 {
		return ErrWrongSize
	}

	pkt.RecipientID = buf.ReadUInt8()
	pkt.SenderID = buf.ReadUInt8()

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}

	pkt.ChunkPos = buf.ReadUInt32()

	var crc = buf.ReadUInt32()
	pkt.Data = buf.ReadBlob(size - 18)
	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return ErrInvalidChecksum
	}

	return nil
}

// MapPartOK implements the [0x44] W3GS_MapPartOK packet (C -> S).
//
// The client sends this when it has successfully received a chunk of the map file from the host client.
//
// Format:
//
//     (UINT8) From player number
//     (UINT8) To player number
//    (UINT32) Unknown (0x01)
//    (UINT32) Chunk position in file
//
type MapPartOK struct {
	SenderID    uint8
	RecipientID uint8
	ChunkPos    uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *MapPartOK) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPartOK)
	buf.WriteUInt16(14)

	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt8(pkt.RecipientID)
	buf.WriteUInt32(1)
	buf.WriteUInt32(pkt.ChunkPos)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapPartOK) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 14 {
		return ErrWrongSize
	}

	pkt.SenderID = buf.ReadUInt8()
	pkt.RecipientID = buf.ReadUInt8()

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}
	pkt.ChunkPos = buf.ReadUInt32()

	return nil
}

// MapPartError implements the [0x45] W3GS_MapPartError packet (C -> S).
//
// This is sent when downloading a map in reply to 0x43 W3GS_MapPart and a chunk of the map file does not match its CRC encryption.
//
// Format:
//
//    [unknown]
//
type MapPartError struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *MapPartError) Serialize(buf *util.PacketBuffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPartError)
	buf.WriteUInt16(4)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapPartError) Deserialize(buf *util.PacketBuffer) error {
	if readPacketSize(buf) != 4 {
		return ErrWrongSize
	}
	return nil
}
