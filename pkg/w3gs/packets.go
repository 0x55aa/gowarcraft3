package w3gs

import (
	"errors"
	"hash/crc32"
	"net"
)

// Errors
var (
	errMalformedData   = errors.New("w3gs: Malformed input data")
	errInvalidChecksum = errors.New("w3gs: Checksum invalid")
)

// UnknownPacket is used to store unknown packets.
type UnknownPacket struct {
	Blob []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *UnknownPacket) MarshalBinary() ([]byte, error) {
	return pkt.Blob, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *UnknownPacket) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errMalformedData
	}
	pkt.Blob = append([]byte(nil), data...)
	return nil
}

// PingFromHost implements the [0x01] W3GS_PING_FROM_HOST packet (S -> C).
//
// This is sent every 30 seconds to make sure that the client is still responsive.
//
// Format:
//
//    (UINT32) Ping
//
type PingFromHost struct {
	Ping uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PingFromHost) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidPingFromHost, 8, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(4, pkt.Ping)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PingFromHost) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.Ping = buf.readUInt32()
	return nil
}

// SlotInfoJoin implements the [0x04] W3GS_SlotInfoJoin packet (S -> C).
//
// This is sent to tell the client about the game slots, upon entry of the lobby.
//
// Format:
//
//    Embedded [0x09] W3GS_SlotInfo:
//	     (UINT16)   Length of Slot data
//	     (UINT8)    Number of slots
//	     (UINT8)[]  Slot data
//	    (UINT32)    Random seed
//	     (UINT8)    Slots layout
//	     (UINT8)    Number of player slots without observers
//
//     (UINT8)    Player number
//    (UINT16)    AF_INET (0x02)
//    (UINT16)    Port
//    (UINT32)    External IP
//    (UINT32)    Unknown (0x00)
//    (UINT32)    Unknown (0x00)
//
type SlotInfoJoin struct {
	SlotInfo     SlotInfo
	PlayerID     uint8
	ExternalPort uint16
	ExternalIP   net.IP
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *SlotInfoJoin) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 30+len(pkt.SlotInfo.Slots)*9)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidSlotInfoJoin)

	// Placeholder for packet size
	buf.writeUInt16(0)

	pkt.SlotInfo.write(&buf)
	buf.writeUInt8(pkt.PlayerID)

	buf.writeUInt16(connAddressFamily)
	buf.writePort(pkt.ExternalPort)
	if err := buf.writeIP(pkt.ExternalIP); err != nil && pkt.ExternalIP != nil {
		return nil, err
	}

	buf.writeUInt32(0)
	buf.writeUInt32(0)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *SlotInfoJoin) UnmarshalBinary(data []byte) error {
	if len(data) < 30 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}

	if err := pkt.SlotInfo.read(&buf); err != nil {
		return err
	}

	if buf.size() != 17 {
		return errMalformedData
	}

	pkt.PlayerID = buf.readUInt8()

	buf.skip(2)
	pkt.ExternalPort = buf.readPort()
	pkt.ExternalIP = buf.readIP()

	return nil
}

// RejectJoin implements the [0x05] W3GS_RejectJoin packet (S -> C).
//
// This is sent in a response to a request to join the game lobby and indicates that the request was denied.
//
// Reason:
//
//    0x09 RejectJoin_FULL      The game lobby is full
//    0x07 RejectJoin_INVALID   There was an error in your request
//    0x10 RejectJoin_STARTED   The game has already been started
//    0x27 RejectJoin_WRONGPASS The password you sent was incorrect
//
// Format:
//
//    (UINT32) Reason
//
type RejectJoin struct {
	Reason uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *RejectJoin) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidRejectJoin, 8, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(4, pkt.Reason)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *RejectJoin) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.Reason = buf.readUInt32()
	return nil
}

// PlayerInfo implements the [0x06] W3GS_PlayerInfo packet (S -> C).
//
// Tells a client about a player's information.
//
// The external and internal IP are always zero for the host.
//
// NOTE: This packet needs a better structure in the Format. Until then, you will have to deal with the unorganized fields.
//
// Format:
//
//     (UINT32) Player Counter
//      (UINT8) Player number
//    (STRING) Player name
//      (UINT16) Unknown (0x01)
//      (UINT16) AF_INET (0x02)
//      (UINT16) Port
//     (UINT32) External IP
//     (UINT32) Unknown (0x00)
//     (UINT32) Unknown (0x00)
//      (UINT16) AF_INET (0x02)
//      (UINT16) Port
//     (UINT32) Internal IP
//     (UINT32) Unknown (0x00)
//     (UINT32) Unknown (0x00)
//
type PlayerInfo struct {
	JoinCounter  uint32
	PlayerID     uint8
	PlayerName   string
	ExternalPort uint16
	ExternalIP   net.IP
	InternalPort uint16
	InternalIP   net.IP
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PlayerInfo) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 44+len(pkt.PlayerName))}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidPlayerInfo)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt32(pkt.JoinCounter)
	buf.writeUInt8(pkt.PlayerID)
	buf.writeString(pkt.PlayerName)

	buf.writeUInt16(1)

	buf.writeUInt16(connAddressFamily)
	buf.writePort(pkt.ExternalPort)
	if err := buf.writeIP(pkt.ExternalIP); err != nil && pkt.ExternalIP != nil {
		return nil, err
	}

	buf.writeUInt32(0)
	buf.writeUInt32(0)

	buf.writeUInt16(connAddressFamily)
	buf.writePort(pkt.InternalPort)
	if err := buf.writeIP(pkt.InternalIP); err != nil && pkt.InternalIP != nil {
		return nil, err
	}

	buf.writeUInt32(0)
	buf.writeUInt32(0)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PlayerInfo) UnmarshalBinary(data []byte) error {
	if len(data) < 44 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.JoinCounter = buf.readUInt32()
	pkt.PlayerID = buf.readUInt8()

	var err error
	if pkt.PlayerName, err = buf.readString(); err != nil {
		return err
	}
	if len(data) != 44+len(pkt.PlayerName) {
		return errMalformedData
	}

	buf.skip(4)
	pkt.ExternalPort = buf.readPort()
	pkt.ExternalIP = buf.readIP()

	buf.skip(10)
	pkt.InternalPort = buf.readPort()
	pkt.InternalIP = buf.readIP()

	if buf.size() != 8 {
		return errMalformedData
	}

	return nil
}

// PlayerLeft implements the [0x07] W3GS_PlayerLeft packet (S -> C).
//
// This is received from the game host when a player leaves.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT8) Player number
//    (UINT32) Reason
//
type PlayerLeft struct {
	PlayerID uint8
	Reason   uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PlayerLeft) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidPlayerLeft, 9, 0, pkt.PlayerID, 0, 0, 0, 0}}
	buf.writeUInt32At(5, pkt.Reason)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PlayerLeft) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.PlayerID = buf.readUInt8()
	pkt.Reason = buf.readUInt32()
	return nil
}

// PlayerLoaded implements the [0x08] W3GS_PlayerLoaded packet (S -> C).
//
// Sent to all other clients in-game to notify that a player has finished loading.
//
// Format:
//
//    (UINT8) Player number
//
type PlayerLoaded struct {
	PlayerID uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PlayerLoaded) MarshalBinary() ([]byte, error) {
	return []byte{protocolsig, pidPlayerLoaded, 5, 0, pkt.PlayerID}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PlayerLoaded) UnmarshalBinary(data []byte) error {
	if len(data) != 5 {
		return errMalformedData
	}
	pkt.PlayerID = data[4]
	return nil
}

// SlotInfo implements the [0x09] W3GS_SlotInfo packet (S -> C).
//
// This is sent for slot updates.
//
// The length of slot info should always be `0x0B`.
//
// Format:
//
//     (UINT16)   Length of Slot data
//     (UINT8)    Number of slots
//     (UINT8) [] Slot data
//    (UINT32)    Random seed
//     (UINT8)    Slots layout
//     (UINT8)    Number of player slots without observers
//
//    For each slot:
//       (UINT8) Player number
//       (UINT8) Download status
//       (UINT8) Slot status
//       (UINT8) Computer status
//       (UINT8) Team
//       (UINT8) Color
//       (UINT8) Race
//       (UINT8) Computer type
//       (UINT8) Handicap
//
type SlotInfo struct {
	Slots      []SlotData
	RandomSeed uint32
	SlotLayout uint8
	NumPlayers uint8
}

// SlotData stores the info for a single game slot.
//
// **Download status:**
//
// - This is a percentage of their download progress. As such, this value can only be between 0 and 100.
//
// Slot status:
//
//    0x00 Open
//    0x01 Closed
//    0x02 Occupied
//
// Computer status:
//
//    0x00 Human
//    0x01 Computer
//
// Race:
//
//    0x01 Human
//    0x02 Orc
//    0x04 Night Elf
//    0x08 Undead
//    0x20 Random
//    0x40 Selectable
//
// Computer type:
//
//    0x00 Easy
//    0x01 Normal / Human
//    0x02 Hard
//
//    (UINT8) Player number
//    (UINT8) Download status
//    (UINT8) Slot status
//    (UINT8) Computer status
//    (UINT8) Team
//    (UINT8) Color
//    (UINT8) Race
//    (UINT8) Computer type
//    (UINT8) Handicap
//
type SlotData struct {
	PlayerID       uint8
	DownloadStatus uint8
	SlotStatus     uint8
	Computer       bool
	Team           uint8
	Color          uint8
	Race           uint8
	ComputerType   uint8
	Handicap       uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *SlotInfo) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 13+len(pkt.Slots)*9)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidSlotInfo)

	// Placeholder for packet size
	buf.writeUInt16(0)

	pkt.write(&buf)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *SlotInfo) UnmarshalBinary(data []byte) error {
	if len(data) < 13 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}

	if err := pkt.read(&buf); err != nil {
		return err
	}

	if buf.size() != 0 {
		return errMalformedData
	}

	return nil
}

func (pkt *SlotInfo) write(buf *packetBuffer) {
	buf.writeUInt16(uint16(7 + len(pkt.Slots)*9))
	buf.writeUInt8(uint8(len(pkt.Slots)))

	for i := 0; i < len(pkt.Slots); i++ {
		buf.writeUInt8(pkt.Slots[i].PlayerID)
		buf.writeUInt8(pkt.Slots[i].DownloadStatus)
		buf.writeUInt8(pkt.Slots[i].SlotStatus)
		buf.writeBool(pkt.Slots[i].Computer)
		buf.writeUInt8(pkt.Slots[i].Team)
		buf.writeUInt8(pkt.Slots[i].Color)
		buf.writeUInt8(pkt.Slots[i].Race)
		buf.writeUInt8(pkt.Slots[i].ComputerType)
		buf.writeUInt8(pkt.Slots[i].Handicap)
	}

	buf.writeUInt32(pkt.RandomSeed)
	buf.writeUInt8(pkt.SlotLayout)
	buf.writeUInt8(pkt.NumPlayers)
}

func (pkt *SlotInfo) read(buf *packetBuffer) error {
	var slotSize = int(buf.readUInt16())
	var numSlots = int(buf.readUInt8())

	if buf.size()+1 < slotSize || slotSize != 7+numSlots*9 {
		return errMalformedData
	}

	if numSlots > 0 {
		pkt.Slots = make([]SlotData, numSlots)
		for i := 0; i < len(pkt.Slots); i++ {
			pkt.Slots[i].PlayerID = buf.readUInt8()
			pkt.Slots[i].DownloadStatus = buf.readUInt8()
			pkt.Slots[i].SlotStatus = buf.readUInt8()
			pkt.Slots[i].Computer = buf.readBool()
			pkt.Slots[i].Team = buf.readUInt8()
			pkt.Slots[i].Color = buf.readUInt8()
			pkt.Slots[i].Race = buf.readUInt8()
			pkt.Slots[i].ComputerType = buf.readUInt8()
			pkt.Slots[i].Handicap = buf.readUInt8()
		}
	} else {
		pkt.Slots = nil
	}

	pkt.RandomSeed = buf.readUInt32()
	pkt.SlotLayout = buf.readUInt8()
	pkt.NumPlayers = buf.readUInt8()

	return nil
}

// CountDownStart implements the [0x0A] W3GS_COUNTDOWN_START packet (S -> C).
//
// The game has begun the countdown to start.
//
// The official clients countdown from 5 seconds, however it is possible to use any time you wish. For example, the GHost++ bot uses 10 seconds when auto-hosted, but 5 seconds when started using an administrative command.
//
// Format:
//
//    [blank]
//
type CountDownStart struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *CountDownStart) MarshalBinary() ([]byte, error) {
	return []byte{protocolsig, pidCountDownStart, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *CountDownStart) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errMalformedData
	}
	return nil
}

// CountDownEnd implements the [0x0B] W3GS_COUNTDOWN_END packet (S -> C).
//
// The game has finished the countdown and has now started. Players should see a loading screen for the map once this is received.
//
// W3GS_COUNTDOWN_START should be received before this packet, even if there is no countdown or if the countdown was 0 seconds.
//
// Format:
//
//    [blank]
//
type CountDownEnd struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *CountDownEnd) MarshalBinary() ([]byte, error) {
	return []byte{protocolsig, pidCountDownEnd, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *CountDownEnd) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errMalformedData
	}
	return nil
}

// IncomingAction implements the [0x0C] W3GS_INCOMING_ACTION packet (S -> C).
//
// Informs the client about an action in-game.
//
// Format:
//
//    (UINT16) Send interval
//    (UINT16) CRC-16 encryption
//
//    For each action:
//    (UINT8) Player number
//    (UINT16) Length of action data
//    (VOID) Action data
//
type IncomingAction struct {
	Fragment     bool
	SendInterval uint16
	Actions      []PlayerAction
}

// PlayerAction stores the data for a single game action.
//
//    (UINT8) Player number
//    (UINT16) Length of action data
//    (VOID) Action data
//
type PlayerAction struct {
	PlayerID uint8
	Data     []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *IncomingAction) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 8+len(pkt.Actions)*16)}
	buf.writeUInt8(protocolsig)

	if pkt.Fragment {
		buf.writeUInt8(pidIncomingAction2)
	} else {
		buf.writeUInt8(pidIncomingAction)
	}

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt16(pkt.SendInterval)

	// Placeholder for CRC
	buf.writeUInt16(0)

	for i := 0; i < len(pkt.Actions); i++ {
		buf.writeUInt8(pkt.Actions[i].PlayerID)
		buf.writeUInt16(uint16(len(pkt.Actions[i].Data)))
		buf.writeBlob(pkt.Actions[i].Data)
	}

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	// Set CRC
	buf.writeUInt16At(6, uint16(crc32.ChecksumIEEE(buf.bytes[8:])))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *IncomingAction) UnmarshalBinary(data []byte) error {
	if len(data) < 6 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[1:]}
	pkt.Fragment = buf.readUInt8() == pidIncomingAction2

	buf.skip(2)
	pkt.SendInterval = buf.readUInt16()

	if len(data) == 6 {
		pkt.Actions = nil
		return nil
	}

	var crc = buf.readUInt16()
	if crc != uint16(crc32.ChecksumIEEE(data[8:])) {
		return errInvalidChecksum
	}

	for buf.size() > 3 {
		var action = PlayerAction{
			PlayerID: buf.readUInt8(),
		}

		var size = int(buf.readUInt16())
		if buf.size() < size {
			return errMalformedData
		}

		action.Data = buf.readBlob(int(size))
		pkt.Actions = append(pkt.Actions, action)
	}

	if buf.size() != 0 {
		return errMalformedData
	}

	return nil
}

// ChatFromHost implements the [0x0F] W3GS_CHAT_FROM_HOST packet (S -> C).
//
// This is sent to the clients to print a message on the screen from another player.
//
// Format:
//
//    (UINT8) Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8) Player number that sent the message
//    (UINT8) Flags
//    (UINT32) Extra Flags
//    (STRING) Message
//
type ChatFromHost struct {
	RecipientIDs []uint8
	SenderID     uint8
	Flags        uint8
	ExtraFlags   uint32
	Message      string
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *ChatFromHost) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 12+len(pkt.RecipientIDs)+len(pkt.Message))}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidChatFromHost)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt8(uint8(len(pkt.RecipientIDs)))
	buf.writeBlob(pkt.RecipientIDs)
	buf.writeUInt8(pkt.SenderID)
	buf.writeUInt8(pkt.Flags)
	buf.writeUInt32(pkt.ExtraFlags)
	buf.writeString(pkt.Message)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *ChatFromHost) UnmarshalBinary(data []byte) error {
	if len(data) < 12 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	var numRecipients = int(buf.readUInt8())

	if len(data) < 12+numRecipients {
		return errMalformedData
	}

	pkt.RecipientIDs = buf.readBlob(numRecipients)
	pkt.SenderID = buf.readUInt8()
	pkt.Flags = buf.readUInt8()
	pkt.ExtraFlags = buf.readUInt32()

	var err error
	if pkt.Message, err = buf.readString(); err != nil {
		return err
	}

	if buf.size() != 0 {
		return errMalformedData
	}

	return nil
}

// StartLag implements the [0x10] W3GS_START_LAG packet (S -> C).
//
// This is sent to the clients to initiate the lag screen.
//
// Format:
//
//    (UINT8) Number of lagging players
//
//    For every lagging player:
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type StartLag struct {
	Players []LagPlayer
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *StartLag) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 5+len(pkt.Players)*5)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidStartLag)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt8(uint8(len(pkt.Players)))
	for i := 0; i < len(pkt.Players); i++ {
		pkt.Players[i].write(&buf)
	}

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *StartLag) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	var numPlayers = int(buf.readUInt8())

	if len(data) != 5+numPlayers*5 {
		return errMalformedData
	}

	if numPlayers > 0 {
		pkt.Players = make([]LagPlayer, numPlayers)
		for i := 0; i < len(pkt.Players); i++ {
			pkt.Players[i].read(&buf)
		}
	} else {
		pkt.Players = nil
	}

	return nil
}

// LagPlayer stores the data for a single lagging player.
//
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type LagPlayer struct {
	PlayerID      uint8
	LagDurationMS uint32
}

func (lp *LagPlayer) write(buf *packetBuffer) {
	buf.writeUInt8(lp.PlayerID)
	buf.writeUInt32(lp.LagDurationMS)
}

func (lp *LagPlayer) read(buf *packetBuffer) {
	lp.PlayerID = buf.readUInt8()
	lp.LagDurationMS = buf.readUInt32()
}

// StopLag implements the [0x11] W3GS_STOP_LAG packet (S -> C).
//
// This is sent to the clients to indicate that a player stopped lagging.
//
// Format:
//
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type StopLag struct {
	Player LagPlayer
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *StopLag) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 9)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidStopLag)

	// Placeholder for packet size
	buf.writeUInt16(0)

	pkt.Player.write(&buf)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *StopLag) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.Player.read(&buf)
	return nil
}

// LeaveAck implements the [0x1B] W3GS_LeaveAck packet (S -> C).
//
// This is the response to 0x21 W3GS_LeaveReq.
//
// You will leave the game once the connection is terminated.
//
// Format:
//
//    [blank]
//
type LeaveAck struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *LeaveAck) MarshalBinary() ([]byte, error) {
	return []byte{protocolsig, pidLeaveAck, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *LeaveAck) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errMalformedData
	}
	return nil
}

// ReqJoin implements the [0x1E] W3GS_ReqJoin packet (C -> S).
//
// A client sends this to the host to enter the game lobby.
//
// The internal IP uses the Windows in_addr structure which is thus used by the sockaddr_in structure.
//
// Format:
//
//    (UINT32) Host Counter (Game ID)
//    (UINT32) Entry Key (used in LAN)
//    (UINT8) Unknown (0)
//    (UINT16) Listen Port
//    (UINT32) Peer Key
//    (STRING) Player name
//    (UINT32) Unknown
//    (UINT16) Internal Port
//    (UINT32) Internal IP
//
type ReqJoin struct {
	HostCounter  uint32
	EntryKey     uint32
	ListenPort   uint16
	PeerKey      uint32
	PlayerName   string
	InternalPort uint16
	InternalIP   net.IP
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *ReqJoin) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 38+len(pkt.PlayerName))}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidReqJoin)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt32(pkt.HostCounter)
	buf.writeUInt32(pkt.EntryKey)

	buf.writeUInt8(0)

	buf.writeUInt16(pkt.ListenPort)
	buf.writeUInt32(pkt.PeerKey)
	buf.writeString(pkt.PlayerName)

	buf.writeUInt16(0)

	buf.writeUInt16(connAddressFamily)
	buf.writePort(pkt.InternalPort)
	if err := buf.writeIP(pkt.InternalIP); err != nil && pkt.InternalIP != nil {
		return nil, err
	}

	buf.writeUInt32(0)
	buf.writeUInt32(0)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *ReqJoin) UnmarshalBinary(data []byte) error {
	if len(data) < 38 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.HostCounter = buf.readUInt32()
	pkt.EntryKey = buf.readUInt32()

	buf.skip(1)

	pkt.ListenPort = buf.readUInt16()
	pkt.PeerKey = buf.readUInt32()

	var err error
	if pkt.PlayerName, err = buf.readString(); err != nil {
		return err
	}

	if len(data) != 38+len(pkt.PlayerName) {
		return errMalformedData
	}

	buf.skip(4)

	pkt.InternalPort = buf.readPort()
	pkt.InternalIP = buf.readIP()

	return nil
}

// LeaveReq implements the [0x21] W3GS_LeaveReq packet (C -> S).
//
// A client requests to leave.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT32) Reason
//
type LeaveReq struct {
	Reason uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *LeaveReq) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidLeaveReq, 8, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(4, pkt.Reason)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *LeaveReq) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.Reason = buf.readUInt32()
	return nil
}

// GameLoadedSelf implements the [0x23] W3GS_GAMELOADED_SELF packet (C -> S).
//
// The client sends this to the host when they have finished loading the map.
//
// Format:
//
//    [blank]
//
type GameLoadedSelf struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *GameLoadedSelf) MarshalBinary() ([]byte, error) {
	return []byte{protocolsig, pidGameLoadedSelf, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *GameLoadedSelf) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errMalformedData
	}
	return nil
}

// OutgoingAction implements the [0x26] W3GS_OUTGOING_ACTION packet (C -> S).
//
// A client sends this to the game host to execute an action in-game.
//
// Format:
//
//    (UINT32) CRC-32 encryption
//    (VOID) Action data
//
type OutgoingAction struct {
	Data []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *OutgoingAction) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 8+len(pkt.Data))}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidOutgoingAction)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.writeBlob(pkt.Data)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *OutgoingAction) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	var crc = buf.readUInt32()

	pkt.Data = append([]byte(nil), data[8:]...)
	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return errInvalidChecksum
	}

	return nil
}

// OutgoingKeepAlive implements the [0x27] W3GS_OUTGOING_KEEPALIVE packet (C -> S).
//
// This is sent to the host from each client.
//
// The unknown value may be a checksum and is also used in replays.
//
// Format:
//
//    (UINT8)  Unknown
//    (UINT32) Checksum
//
type OutgoingKeepAlive struct {
	Checksum uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *OutgoingKeepAlive) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidOutgoingKeepAlive, 9, 0, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(5, pkt.Checksum)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *OutgoingKeepAlive) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[5:]}
	pkt.Checksum = buf.readUInt32()
	return nil
}

// ChatToHost implements the [0x28] W3GS_CHAT_TO_HOST packet (C -> S).
//
// This is sent from the client to the host to send a message to the other clients.
//
// Format:
//
//    (UINT8) Total
//
//    For each total:
//    (UINT8) To player number
//    (UINT8) From player number
//    (UINT8) Flags
//
type ChatToHost struct {
	Messages []ChatToHostMessage
}

// ChatToHostMessage stores the data for a single ChatToHost message.
//
//    (UINT8) To player number
//    (UINT8) From player number
//    (UINT8) Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type ChatToHostMessage struct {
	RecipientID uint8
	SenderID    uint8
	Flags       uint8
	NewVal      uint8
	ExtraFlags  uint32
	Message     string
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *ChatToHost) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 5+len(pkt.Messages)*4)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidChatToHost)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt8(uint8(len(pkt.Messages)))
	for i := 0; i < len(pkt.Messages); i++ {
		buf.writeUInt8(pkt.Messages[i].RecipientID)
		buf.writeUInt8(pkt.Messages[i].SenderID)
		buf.writeUInt8(pkt.Messages[i].Flags)

		switch pkt.Messages[i].Flags {
		case ChatMessageExtra:
			buf.writeUInt32(pkt.Messages[i].ExtraFlags)
			fallthrough
		case ChatMessage:
			buf.writeString(pkt.Messages[i].Message)
		default:
			buf.writeUInt8(pkt.Messages[i].NewVal)
		}
	}

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *ChatToHost) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	var numMessages = int(buf.readUInt8())

	if numMessages > 0 {
		pkt.Messages = make([]ChatToHostMessage, numMessages)
		for i := 0; i < len(pkt.Messages); i++ {
			if buf.size() < 4 {
				return errMalformedData
			}

			pkt.Messages[i].RecipientID = buf.readUInt8()
			pkt.Messages[i].SenderID = buf.readUInt8()
			pkt.Messages[i].Flags = buf.readUInt8()

			switch pkt.Messages[i].Flags {
			case ChatMessageExtra:
				pkt.Messages[i].ExtraFlags = buf.readUInt32()
				fallthrough
			case ChatMessage:
				var err error
				if pkt.Messages[i].Message, err = buf.readString(); err != nil {
					return err
				}
			default:
				pkt.Messages[i].NewVal = buf.readUInt8()
			}
		}
	} else {
		pkt.Messages = nil
	}

	if buf.size() != 0 {
		return errMalformedData
	}

	return nil
}

// DropReq implements the [0x2F] DropReq packet (C -> S).
//
// This is sent when a player votes to drop lagging players.
//
// Format:
//
//    Unknown
//
type DropReq struct {
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *DropReq) MarshalBinary() ([]byte, error) {
	return []byte{protocolsig, pidDropReq, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *DropReq) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errMalformedData
	}
	return nil
}

// SearchGame implements the [0x2F] W3GS_SearchGame packet (C -> S).
//
// This is sent to the entire local area network to detect games.
//
// Product is either WAR3 or W3XP.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Unknown (0x00)
//
type SearchGame struct {
	GameVersion GameVersion
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *SearchGame) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 16)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidSearchGame)

	// Placeholder for packet size
	buf.writeUInt16(0)

	pkt.GameVersion.write(&buf)
	buf.writeUInt32(0)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *SearchGame) UnmarshalBinary(data []byte) error {
	if len(data) != 16 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}

	pkt.GameVersion.read(&buf)

	return nil
}

// GameVersion stores the game version tuple.
//
//    (UINT32) Product
//    (UINT32) Version
//
type GameVersion struct {
	TFT     bool
	Version uint32
}

func (gv *GameVersion) write(buf *packetBuffer) {
	if gv.TFT {
		buf.writeBlob([]byte(gameW3XP))
	} else {
		buf.writeBlob([]byte(gameWAR3))
	}
	buf.writeUInt32(gv.Version)
}

func (gv *GameVersion) read(buf *packetBuffer) {
	gv.TFT = string(buf.readBlob(4)) == gameW3XP
	gv.Version = buf.readUInt32()
}

// GameInfo implements the [0x30] W3GS_GameInfo packet (S -> C).
//
// This is sent every 5 seconds over a UDP broadcast to update the local area network about the game.
//
// This is also sent when a client clicks on the game in a list.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Host Counter
//    (UINT32) Entry key
//    (STRING) Game name
//    (UINT8) Unknown (0x00)
//    (STRING) Statstring
//    (UINT32) Slots total
//    (UINT32) Game Type Info
//    (UINT32) Unknown (0x01)
//    (UINT32) Slots available
//    (UINT32) Time since creation
//    (UINT16) Game Port
//
type GameInfo struct {
	GameVersion       GameVersion
	HostCounter       uint32
	EntryKey          uint32
	GameName          string
	StatString        string
	SlotsTotal        uint32
	GameTypeFlags     uint32
	SlotsAvailable    uint32
	TimeSinceCreation uint32
	GamePort          uint16
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *GameInfo) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 45+len(pkt.GameName)+len(pkt.StatString))}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidGameInfo)

	// Placeholder for packet size
	buf.writeUInt16(0)

	pkt.GameVersion.write(&buf)
	buf.writeUInt32(pkt.HostCounter)
	buf.writeUInt32(pkt.EntryKey)
	buf.writeString(pkt.GameName)
	buf.writeUInt8(0)
	buf.writeString(pkt.StatString)
	buf.writeUInt32(pkt.SlotsTotal)
	buf.writeUInt32(pkt.GameTypeFlags)
	buf.writeUInt32(1)
	buf.writeUInt32(pkt.SlotsAvailable)
	buf.writeUInt32(pkt.TimeSinceCreation)
	buf.writeUInt16(pkt.GamePort)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *GameInfo) UnmarshalBinary(data []byte) error {
	if len(data) < 45 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.GameVersion.read(&buf)
	pkt.HostCounter = buf.readUInt32()
	pkt.EntryKey = buf.readUInt32()

	var err error
	if pkt.GameName, err = buf.readString(); err != nil {
		return err
	}
	if len(data) < 45+len(pkt.GameName) {
		return errMalformedData
	}

	buf.skip(1)
	if pkt.StatString, err = buf.readString(); err != nil {
		return err
	}
	if len(data) != 45+len(pkt.GameName)+len(pkt.StatString) {
		return errMalformedData
	}

	pkt.SlotsTotal = buf.readUInt32()
	pkt.GameTypeFlags = buf.readUInt32()

	buf.skip(4)
	pkt.SlotsAvailable = buf.readUInt32()
	pkt.TimeSinceCreation = buf.readUInt32()
	pkt.GamePort = buf.readUInt16()

	return nil
}

// CreateGame implements the [0x31] W3GS_CreateGame packet (S -> C).
//
// Notifies the local area network that a game was created.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) HostCounter
//
type CreateGame struct {
	GameVersion GameVersion
	HostCounter uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *CreateGame) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 16)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidCreateGame)

	// Placeholder for packet size
	buf.writeUInt16(0)

	pkt.GameVersion.write(&buf)
	buf.writeUInt32(pkt.HostCounter)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *CreateGame) UnmarshalBinary(data []byte) error {
	if len(data) != 16 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.GameVersion.read(&buf)
	pkt.HostCounter = buf.readUInt32()

	return nil
}

// RefreshGame implements the [0x32] W3GS_RefreshGame packet (S -> C).
//
// Notifies the local area network about a game (occurs every 5 seconds or refresh slots).
//
// Format:
//
//    (UINT32) Host Counter
//    (UINT32) Players In Game
//    (UINT32) Slots available
//
type RefreshGame struct {
	HostCounter    uint32
	PlayersInGame  uint32
	SlotsAvailable uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *RefreshGame) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 16)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidRefreshGame)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt32(pkt.HostCounter)
	buf.writeUInt32(pkt.PlayersInGame)
	buf.writeUInt32(pkt.SlotsAvailable)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *RefreshGame) UnmarshalBinary(data []byte) error {
	if len(data) != 16 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.HostCounter = buf.readUInt32()
	pkt.PlayersInGame = buf.readUInt32()
	pkt.SlotsAvailable = buf.readUInt32()

	return nil
}

// DecreateGame implements the [0x33] W3GS_DecreateGame packet (S -> C).
//
// Notifies the local area network that a game is no longer being hosted.
//
// Format:
//
//    (UINT32) Host Counter
//
type DecreateGame struct {
	HostCounter uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *DecreateGame) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidDecreateGame, 8, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(4, pkt.HostCounter)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *DecreateGame) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.HostCounter = buf.readUInt32()
	return nil
}

// PingFromOthers implements the [0x35] W3GS_PING_FROM_OTHERS packet (C -> C).
//
// Client requests an echo from another client (occurs every 10 seconds).
//
// Format:
//
//    (UINT32) Ping
//
type PingFromOthers struct {
	Ping uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PingFromOthers) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidPingFromOthers, 8, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(4, pkt.Ping)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PingFromOthers) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.Ping = buf.readUInt32()
	return nil
}

// PongToOthers implements the [0x36] W3GS_PONG_TO_OTHERS packet (C -> C).
//
// This is sent in response to an echo from another client.
//
// Format:
//
//    (UINT32) Pong
//
type PongToOthers struct {
	Pong uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PongToOthers) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidPongToOthers, 8, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(4, pkt.Pong)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PongToOthers) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.Pong = buf.readUInt32()
	return nil
}

// ClientInfo implements the [0x37] W3GS_ClientInfo packet (C -> S).
//
// A client sends this to another client to gain information about self when connected.
//
// The first byte in the second unknown is possibly the status of the player.
//
// Packet Log:
//    F7 37 12 00
//    02 00 00 00
//    00 00 00 00
//    06
//    FF 5E 00 00 00
//
// Format:
//
//    (UINT32) Player Counter
//    (UINT32) Unknown (0x00)
//    (UINT8) Player number
//    (UINT8)[5] Unknown
//
type ClientInfo struct {
	JoinCounter uint32
	PlayerID    uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *ClientInfo) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 18)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidClientInfo)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt32(pkt.JoinCounter)
	buf.writeUInt32(0)
	buf.writeUInt8(pkt.PlayerID)

	buf.writeUInt8(0)
	buf.writeUInt32(0)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *ClientInfo) UnmarshalBinary(data []byte) error {
	if len(data) != 18 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.JoinCounter = buf.readUInt32()
	buf.skip(4)
	pkt.PlayerID = buf.readUInt8()

	return nil
}

// MapCheck implements the [0x3D] W3GS_MapCheck packet (S -> C).
//
// This is sent from the game host to a client that just joined to check if the client has the map.
//
// The map info is the actual CRC and the other CRC is actually an "xoro" value.
//
// Format:
//
//    (UINT32) Unknown (0x01)
//    (STRING) File Path
//    (UINT32) File size
//    (UINT32) Map info
//    (UINT32) File CRC encryption
//    (UINT8)[20] File SHA-1 hash
//
type MapCheck struct {
	FilePath          string
	FileSize          uint32
	MapInfo           uint32
	FileCrcEncryption uint32
	FileSha1Hash      [20]byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapCheck) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 41+len(pkt.FilePath))}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidMapCheck)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt32(1)
	buf.writeString(pkt.FilePath)
	buf.writeUInt32(pkt.FileSize)
	buf.writeUInt32(pkt.MapInfo)
	buf.writeUInt32(pkt.FileCrcEncryption)
	buf.writeBlob(pkt.FileSha1Hash[:])

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapCheck) UnmarshalBinary(data []byte) error {
	if len(data) < 21 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[8:]}

	var err error
	if pkt.FilePath, err = buf.readString(); err != nil {
		return err
	}

	if len(data) != 41+len(pkt.FilePath) {
		return errMalformedData
	}

	pkt.FileSize = buf.readUInt32()
	pkt.MapInfo = buf.readUInt32()
	pkt.FileCrcEncryption = buf.readUInt32()
	copy(pkt.FileSha1Hash[:], buf.readBlob(20))

	return nil
}

// StartDownload implements the [0x3F] W3GS_StartDownload packet (C -> S, S -> C).
//
// C -> S: Client sends this to the host to initiate a map download.
// S -> C: This tells the client that it is now in the downloading state and should expect chunks of file data.
//
// Format:
//
//    (UINT32) Unknown (0x01) [if S -> C]
//    (UINT8) Player number   [if S -> C]
//
type StartDownload struct {
	PlayerID uint8
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *StartDownload) MarshalBinary() ([]byte, error) {
	//if pkt.PlayerID > 0 {
	return []byte{protocolsig, pidStartDownload, 9, 0, 0, 0, 0, 0, pkt.PlayerID}, nil
	//}

	//return []byte{protocolsig, pidStartDownload, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *StartDownload) UnmarshalBinary(data []byte) error {
	switch len(data) {
	// case 4:
	// 	pkt.PlayerID = 0
	case 9:
		pkt.PlayerID = data[8]
	default:
		return errMalformedData
	}

	return nil
}

// MapSize implements the [0x42] W3GS_MapSize packet (C -> S).
//
// This is sent from the client to tell the host about the map file on the client's local system.
//
// Format:
//
//    (UINT32) Unknown
//    (UINT8) Size Flag
//    (UINT32) Map Size
//
type MapSize struct {
	Ready   bool
	MapSize uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapSize) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 13)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidMapSize)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt32(0)

	if pkt.Ready {
		buf.writeUInt8(1)
	} else {
		buf.writeUInt8(3)
	}

	buf.writeUInt32(pkt.MapSize)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapSize) UnmarshalBinary(data []byte) error {
	if len(data) != 13 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[8:]}
	pkt.Ready = buf.readUInt8() == 1
	pkt.MapSize = buf.readUInt32()

	return nil
}

// MapPart implements the [0x43] W3GS_MapPart packet (S -> C).
//
// This is received when you are downloading a map from the host.
//
// You can calculate how many more chunks you have left based on the file size and the chunk position in file. You are done downloading when the chunk position in file (plus the size of the chunk) matches the file size received in 0x42 W3GS_MapSize.
//
// If the data does not match the CRC-32, you should send the host 0x45 W3GS_MapPartError, otherwise you should always send 0x44 W3GS_MapPartOK in reply to this packet.
//
// Format:
//
//    (UINT8) To player number
//    (UINT8) From player number
//    (UINT32) Unknown (0x01)
//    (UINT32) Chunk position in file
//    (UINT32) CRC-32 encryption
//    (UINT8)[1442] Data
//
type MapPart struct {
	RecipientID         uint8
	SenderID            uint8
	ChunkPositionInFile uint32
	Data                []byte
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapPart) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 18+len(pkt.Data))}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidMapPart)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt8(pkt.RecipientID)
	buf.writeUInt8(pkt.SenderID)
	buf.writeUInt32(1)
	buf.writeUInt32(pkt.ChunkPositionInFile)

	buf.writeUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.writeBlob(pkt.Data)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapPart) UnmarshalBinary(data []byte) error {
	if len(data) < 18 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}

	pkt.RecipientID = buf.readUInt8()
	pkt.SenderID = buf.readUInt8()
	buf.skip(4)
	pkt.ChunkPositionInFile = buf.readUInt32()

	var crc = buf.readUInt32()
	pkt.Data = buf.readBlob(buf.size())
	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return errInvalidChecksum
	}

	return nil
}

// MapPartOK implements the [0x44] W3GS_MapPartOK packet (C -> S).
//
// The client sends this when it has successfully received a chunk of the map file from the host client.
//
// Format:
//
//    (UINT8) From player number
//    (UINT8) To player number
//    (UINT32) Unknown
//    (UINT32) Chunk position in file
//
type MapPartOK struct {
	SenderID            uint8
	RecipientID         uint8
	ChunkPositionInFile uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapPartOK) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: make([]byte, 0, 14)}
	buf.writeUInt8(protocolsig)
	buf.writeUInt8(pidMapPartOK)

	// Placeholder for packet size
	buf.writeUInt16(0)

	buf.writeUInt8(pkt.SenderID)
	buf.writeUInt8(pkt.RecipientID)
	buf.writeUInt32(0)
	buf.writeUInt32(pkt.ChunkPositionInFile)

	// Set packet size
	buf.writeUInt16At(2, uint16(buf.size()))

	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapPartOK) UnmarshalBinary(data []byte) error {
	if len(data) != 14 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.SenderID = buf.readUInt8()
	pkt.RecipientID = buf.readUInt8()

	buf.skip(4)
	pkt.ChunkPositionInFile = buf.readUInt32()

	return nil
}

// MapPartError implements the [0x45] W3GS_MapPartError packet (C -> S).
//
// More research is required.
//
// This is sent when downloading a map in reply to 0x43 W3GS_MapPart and a chunk of the map file does not match its CRC encryption.
//
// Format:
//
//    [unknown]
//
type MapPartError struct {
	// Empty
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *MapPartError) MarshalBinary() ([]byte, error) {
	return []byte{protocolsig, pidMapPartError, 4, 0}, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *MapPartError) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errMalformedData
	}
	return nil
}

// PongToHost implements the [0x46] W3GS_PONG_TO_HOST packet (C -> S).
//
// This is sent in response to 0x01 W3GS_PONG_FROM_HOST.
//
// The pong value is just a copy of whatever was sent in SEND_W3GS_PING_FROM_HOST which was GetTicks( ) at the time of sending
// so as long as we trust that the client isn't trying to fake us out and mess with the pong value we can find the round trip time by simple subtraction
// (the subtraction is done elsewhere because the very first pong value seems to be 1 and we want to discard that one)
//
// Format:
//
//    (UINT32) Pong
//
type PongToHost struct {
	Pong uint32
}

// MarshalBinary encodes the struct into its binary form.
func (pkt *PongToHost) MarshalBinary() ([]byte, error) {
	var buf = packetBuffer{bytes: []byte{protocolsig, pidPongToHost, 8, 0, 0, 0, 0, 0}}
	buf.writeUInt32At(4, pkt.Pong)
	return buf.bytes, nil
}

// UnmarshalBinary decodes the binary data generated by MarshalBinary.
func (pkt *PongToHost) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errMalformedData
	}

	var buf = packetBuffer{bytes: data[4:]}
	pkt.Pong = buf.readUInt32()
	return nil
}
